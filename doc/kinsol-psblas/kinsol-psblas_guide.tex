\documentclass[twoside,a4paper]{refart}

\usepackage[utf8]{inputenc}
\usepackage{ae}
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}

\title{PSBLAS-KINSOL interface}
\author{Istituto per le Applicazioni del Calcolo ``M. Picone'',\\
	Consiglio Nazionale delle Ricerche \\
	Pasqua D'Ambra \\
	Fabio Durastante \\
	Salvatore Filippone \\
	PSBLAS 3.6.1 --- Interface Version 1}
\date{\today}
\emergencystretch1em 

\setcounter{tocdepth}{2}
\settextfraction{0.7}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstdefinestyle{CStyle}{
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
%	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C,
	morekeywords={N_Vector,sunindextype,psb_i_t,psb_c_descriptor,psb_c_dvector,booleantype,psb_c_info,psb_c_init,psb_cdall,psb_c_cdall_vl,psb_l_t}
}

\usepackage[backend=biber]{biblatex}
\bibliography{bibliography}

\begin{document}
	\maketitle
	
	\tableofcontents
	\newpage
	
	\section{The logic behind a PSBLAS instrumented application}
	
	The main aim of the PSBLAS library is the parallel implementation of iterative solvers
	for sparse linear systems,
	\begin{equation}\label{eq:linear_system}
		A \mathbf{x} = \mathbf{b}, \qquad A \in \mathbb{K}^{n \times n}, \qquad \mathbb{K} = \mathbb{R}, \mathbb{C},
	\end{equation}
	through the distributed memory paradigm operating with message
	passing. The library includes all the needed routines for this task, e.g, functions for multiplying sparse matrices by dense matrices, for solving block diagonal systems with triangular diagonal entries or for preprocessing sparse matrices.
	
	The pivotal choice to be made in this setting regards the distribution of the coefficient matrix $A$ for the linear system~\eqref{eq:linear_system}. In PSBLAS this choice is based on the \textbf{owner computes rule} \marginlabel{\textbf{Owner computes rule}}: each unknown is assigned to a process that will  own the corresponding row in the coefficient matrix and
	will  carry out all related computations. 
	
	If $A$ is obtained from the discretization of a Partial Differential Equation (PDE), this allocation strategy is equivalent to the choice of a partition of the mesh into {\em
		sub-domains}.
	 
	\attention PSBLAS supports \emph{any} distribution that keeps together 
	the coefficients of each matrix row there are \textbf{no other} constraints on
	the variable assignment. 
	
	Any PSBLAS application will always start with the construction of the parallel environment, i.e., of an MPI (virtual) parallel machine, that we call here context by means of the \lstinline[style=CStyle]|psb_c_init| function~as
\begin{lstlisting}[style=CStyle]
psb_i_t ictxt, iam, np;
ictxt = psb_c_init();
psb_c_info(ictxt,&iam,&np);
\end{lstlisting}
	that creates a parallel environment on \lstinline[style=CStyle]|np| processors $0,\ldots,\lstinline[style=CStyle]|np|-1$, of which we are process \lstinline[style=CStyle]|iam|.
	
	The next step is represented by the need of subdividing the index space among processes, and this creates a mapping from the ``global'' numbering $1,\ldots,n$ to a ``local'' numbering
	in each process. This means that each process $i$ will own a certain subset
	$1,\ldots,n_{\hbox{row}_i}$, each element of which corresponds to a certain element of $1\dots n$.
	
	Therefore, after the initialization the first step is to establish an index space, and
	this is done with a call to one of the variants of the \lstinline[style=CStyle]|psb_cdall| function to allocate a descriptor object \lstinline[style=CStyle]|psb_c_descriptor|:
\begin{description}
	\item[\fbox{\texttt{psb\_c\_cdall\_vg}}] the association between an index and a process is specified via an integer vector \lstinline[style=CStyle]|vg[]|, each index $i \in \{1,\ldots,\lstinline[style=CStyle]|ng|\}$ is assigned to process \lstinline[style=CStyle]|vg[i]|. The vector \lstinline[style=CStyle]|vg[]| must be identical on all calling processes, and its entries have the ranges $(0,\ldots,\lstinline[style=CStyle]|np|-1)$ or
	$(1,\ldots,\lstinline[style=CStyle]|np|)$ according to the fact that \lstinline[style=CStyle]|psb_c_set_index_base(0)| or \lstinline[style=CStyle]|psb_c_set_index_base(1)| has been called at the beginning. The size \lstinline[style=CStyle]|ng| is specified one can chose to use the entire
	vector \lstinline[style=CStyle]|vg[]|, thus having \lstinline[style=CStyle]|vg[ng]|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_vg(psb_l_t ng,psb_i_t *vg,psb_i_t ictxt,psb_c_descriptor *cdh);|
	\item[\fbox{\texttt{psb\_c\_cdall\_vl}}] the association is done by specifying the list of indices \lstinline[style=CStyle]|vl[nl]| assigned to
	the current process; thus, the global problem size \lstinline[style=CStyle]|nl| is given by
	the range of the aggregate of the individual vectors \lstinline[style=CStyle]|vl[]| specified in
	the calling processes. The subroutine will check how
	many times each entry in the global index space $(1,\ldots,\lstinline[style=CStyle]|nl|)$ is specified
	in the input lists \lstinline[style=CStyle]|vl[]|, therefore it allows for the presence of overlap in the
	input, and checks for the ``orphan'' indices. 
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_vl(psb_i_t nl,psb_l_t *vl,psb_i_t ictxt,psb_c_descriptor *cdh);|
	\item[\fbox{\texttt{psb\_c\_cdall\_nl}}] produces a generalized block-row distribution of the number of indices belonging to the current process in which each process $i$ gets assigned
	a consecutive chunk of $nl$ global indices,
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_nl(psb_i_t nl,psb_i_t ictxt, psb_c_descriptor *cdh);|
\end{description}
	for the case of a simple minded block distribution, i.e., the index space is first numbered sequentially in a standard way, then the corresponding vector is distributed according to a block distribution directive. 
	%The discretization ensures there are IDIM *internal* points in each direction.
	
\noindent\rule{\columnwidth}{0.4pt}
We consider as example the finite difference discretization of the following boundary value problem
\begin{equation}\label{eq:boundaryproblem}
	- \frac{b_1 \partial^2 u}{\partial x^2} - \frac{b_2 \partial^2 u}{\partial y^2} - \frac{b_3 \partial^2 u}{\partial z^2} + \frac{a_1 \partial u}{\partial x} + \frac{a_2 \partial u}{\partial y} + a_3 \frac{a_3 \partial u}{\partial z} = 0, 
\end{equation}
for $(x,y,z) \in [0,1]^3$, with Dirichlet boundary conditions, on a uniform grid with \lstinline[style=CStyle]|idim| node per size. All the allocation procedure can be expressed as
\begin{lstlisting}[style=CStyle,caption="Example of allocation procedure for a 3D block data distribution",label=lst:example_of_allocation]
psb_c_descriptor *cdh;
psb_i_t idim,nb,nlr, nl;
psb_l_t i,ng, *vl, k;

cdh=psb_c_new_descriptor();
psb_c_set_index_base(0);

/* Simple minded BLOCK data distribution */ 
ng = ((psb_l_t) idim)*idim*idim;  
nb = (ng+np-1)/np;
nl = nb;
if ( (ng -iam*nb) < nl) nl = ng -iam*nb; 
fprintf(stderr,"%d: Input data %d %ld %d %d\n",iam,idim,ng,nb, nl);
if ((vl=malloc(nb*sizeof(psb_l_t)))==NULL) {
	fprintf(stderr,"On %d: malloc failure\n",iam);
	psb_c_abort(ictxt);
}
i = ((psb_l_t)iam) * nb;
for (k=0; k<nl; k++)
	vl[k] = i+k; 
psb_c_cdall_vl(nl,vl,ictxt,cdh);
\end{lstlisting}
\noindent\rule{\columnwidth}{0.4pt}	

	Now that the initial distribution of the index space has been performed, we need to allocate  dense vectors and sparse matrices on such index space, and thus we define the complete topology of our computational problem. Since our task is to use the capabilities of SUNDIALS-KINSOL to solve for nonlinear problems, here lies the core of the interfacing between the two codes. In the next two Sections~\ref{sec:nvector}, and Section~\ref{sec:sunmatrix} we describe such encapsulation for dense vector, and sparse matrices. Then in Section~\ref{sec:sunlinsol} we describe the interfacing with the \textbf{linear solvers} and \textbf{preconditioners} 

	Complete information on the PSBLAS data structures, and functions that are mentioned along the text can be found in~\cite{psblasguide}.
	
	
	\section{The NVECTOR\_PSBLAS implementation}\label{sec:nvector}
	The NVECTOR\_PSBLAS implementation of the SUNDIALS NVECTOR module provides an interface to the PSBLAS code for handling distributed dense vectors. 
	It defines the \emph{content} field of \texttt{N\_Vector} to be a structure containing the PSBLAS descriptor for the data distribution, a PSBLAS vector of double, and the PSBLAS communicator (context).
	
\begin{lstlisting}[style=CStyle]
struct _N_VectorContent_PSBLAS {
	booleantype own_data;  /*ownership of data*/
	psb_c_descriptor *cdh; /*descriptor for data distribution*/
	psb_c_dvector *pvec;   /*PSBLAS vector*/
	int ictxt;             /*PSBLAS communicator*/
};
\end{lstlisting}
	
	\attention All the vectors that have to interact needs to be instantiated on the same parallel context \lstinline[style=CStyle]|ictxt|, and on the same data distribution \lstinline[style=CStyle]|cdh|.
	
	
	The header file to include when using this module is \texttt{nvector\_psblas.h}. The installed module library to link to is \texttt{sundials\_nvecpsblas.lib} where \texttt{.lib} is typically \texttt{.so} for shared libraries and \texttt{.a} for static libraries.
	
	\subsection{NVECTOR\_PSBLAS accessor macros}
	
	The following macros are provided to access the content of a NVECTOR\_PSBLAS vector. The suffix \texttt{\_P} in the names denotes the fact that the data are in distributed memory.

\begin{lstlisting}[style=CStyle]
#define NV_CONTENT_P(v)   ((N_VectorContent_PSBLAS)(v->content))
#define NV_DESCRIPTOR_P(v)(NV_CONTENT_P(v)->cdh)
#define NV_OWN_DATA_P(v)  (NV_CONTENT_P(v)->own_data)
#define NV_PVEC_P(v)      (NV_CONTENT_P(v)->pvec)
#define NV_ICTXT_P(v)     (NV_CONTENT_P(v)->ictxt)
\end{lstlisting}

\marginlabel{\lstinline[style=CStyle]|NV_CONTENT_P(v)|} this macro gives access to the contents of the PSBLAS vector \texttt{N\_Vector}.

\marginlabel{\lstinline[style=CStyle]|NV_DESCRIPTOR_P(v),NV_OWN_DATA_P(v),NV_PVEC_P(v)|} these macros give instead individual access to the parts of the content of a PSBLAS parallel \texttt{N\_Vector}.  

\marginlabel{\lstinline[style=CStyle]|NV_ICTXT_P(v)|} this macro provides the PSBLAS context used by the NVECTOR\_PSBLAS vectors.

\subsection{NVECTOR\_PSBLAS functions}

The NVECTOR\_PSBLAS implementation provides PSBLAS implementations of all the vectors operations listed in Tables~6.2, 6.3, and 6.4 of the original KINSOL library~\cite{kinsolguide}. Following the standard nomenclature of the SUNDIALS library, their names are obtained from the ones listed in Tables~6.2, 6.3, and 6.4 by appending the suffix \texttt{\_PSBLAS}. The NVECTOR\_PSBLAS implementation provides the following additional user--callable routine:

\begin{description}
	\item[\fbox{\texttt{N\_VAsb\_PSBLAS}}] This routine assemble the NVector after that all the elements have been inserted into it, i.e., after that all the calls to the \texttt{N\_VMake\_PSBLAS} routine have been completed. This is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dgeasb|.

	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAsb_PSBLAS(N_Vector v)|
\end{description}

\subsubsection{Description of the NVECTOR\_PSBLAS functions}

\begin{description}
	\item[\fbox{\texttt{N\_VNew\_PSBLAS}}] This function creates and allocates memory for a parallel vector
	on the PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh|
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VNew_PSBLAS(int ictxt, psb_c_descriptor *cdh);|
	
	\item[\fbox{\texttt{N\_VNewEmpty\_PSBLAS}}] This function creates a new PSBLAS vector with empty data array.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VNewEmpty_PSBLAS(int ictxt, psb_c_descriptor *cdh);|
	
	\item[\fbox{\texttt{N\_VMake\_PSBLAS}}] Function to create a PSBLAS \texttt{N\_Vector} with user data component. This function is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dgeins|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VMake_PSBLAS(int ictxt, psb_c_descriptor *cdh,psb_i_t m, psb_i_t *irow,double *val);|
	
	The PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh| are the one defined for the whole programs, the integer \lstinline[style=CStyle]{m} is the number of rows in \lstinline[style=CStyle]{val[]} to be inserted, the array of integers \lstinline[style=CStyle]{irow} is the indices of the rows to be inserted. Specifically, row \lstinline[style=CStyle]|i| of \lstinline[style=CStyle]|val| will be inserted into the local row corresponding to the global index row index \lstinline[style=CStyle]|row[i]|.
	
	\attention This routine does not assemble the final vector. After the insertion of all the elements has been completed then the vector should be assembled by means of the \texttt{N\_VAsb\_PSBLAS} routine.
	
	\item[\fbox{\texttt{N\_VCloneVectorArray\_PSBLAS}}] This function creates an array of new parallel vectors (by cloning) an array of \lstinline[style=CStyle]|count| parallel vectors \lstinline[style=CStyle]|v|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector *N_VCloneVectorArray_PSBLAS(int count, N_Vector w)|
	
	\item[\fbox{\texttt{N\_VCloneVectorArrayEmpty\_PSBLAS}}] This function creates an array of \lstinline[style=CStyle]|count| new parallel vectors with empty data array on the same communicator and context of the vector \lstinline[style=CStyle]|w|. 
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector *N_VCloneVectorArrayEmpty_PSBLAS(int count, N_Vector w)|
	
	\item[\fbox{\texttt{N\_VDestroyVectorArray\_PSBLAS}}] This function to frees an array of \lstinline[style=CStyle]|count| \texttt{N\_Vector}s created with \texttt{N\_VCloneVectorArray\_PSBLAS}
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDestroyVectorArray_PSBLAS(N_Vector *vs, int count)|
	
	\item[\fbox{\texttt{N\_VGetLength\_PSBLAS}}] This function returns the \emph{global} vector length, this is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_cd_get_global_rows|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype N_VGetLength_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VGetLocalLength\_PSBLAS}}] This function returns the \emph{local} vector length, this is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_cd_get_local_rows|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype N_VGetLocalLength_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VPrint\_PSBLAS}}] This function prints the local data in a parallel vector to \lstinline[style=CStyle]|stdout|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VPrint_PSBLAS(N_Vector x)|
	
	\item[\fbox{\texttt{N\_VPrintFile\_PSBLAS}}] This function prints the local data in a parallel vector to \lstinline[style=CStyle]|outfile|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VPrintFile_PSBLAS(N_Vector x, FILE* outfile)|
	
	\item[\fbox{\texttt{N\_VGetVectorID\_PSBLAS}}] This function returns the SUNDIALS identificative for the PSBLAS vector, since this is a custom implementation it returns the integer constant \lstinline[style=CStyle]|SUNDIALS_NVEC_CUSTOM|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector_ID N_VGetVectorID_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VCloneEmpty\_PSBLAS}}] Clones a NVECTOR\_PSBLAS with a \lstinline[style=CStyle]|NULL| \lstinline[style=CStyle]|pvec| field, and with value \lstinline[style=CStyle]|SUNFALSE| in the \lstinline[style=CStyle]|own_data| field.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VCloneEmpty_PSBLAS(N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VClone\_PSBLAS}}] Clones a NVECTOR\_PSBLAS allocating its memory following the same communicator of the cloned one.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VClone_PSBLAS(N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VDestroy\_PSBLAS}}] Destroys a NVECTOR\_PSBLAS freeing both the memory allocated for the corresponding PSBLAS vector, and the memory allocated for the NVECTOR\_PSBLAS structure.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDestroy_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VSpace\_PSBLAS}}] Returns storage requirements for one NVECTOR\_PSBLAS. \lstinline[style=CStyle]|lrw| contains the number of realtype words and \lstinline[style=CStyle]|liw| contains the number of integer words.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VSpace_PSBLAS(N_Vector v, sunindextype *lrw,sunindextype *liw)|
 	
 	\item[\fbox{\texttt{N\_VGetArrayPointer\_PSBLAS}}] Returns a pointer to a realtype array from the NVECTOR\_PSBLAS, this is the local portion of the distributed PSBLAS vector encapsulated in the \texttt{N\_Vector} object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype *N_VGetArrayPointer_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VSetArrayPointer\_PSBLAS}}] This function is a dummy function, in PSBLAS we use \lstinline[language=Fortran]|allocatable| objects for the local part of the distributed vector, and, moreover, we assume having an arbitrary distribution of the indexes.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VSetArrayPointer_PSBLAS(psb_c_dvector *v_data, N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VLinearSum\_PSBLAS}}] Performs the AXPBY BLAS operation between to  NVECTOR\_PSBLAS, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VLinearSum_PSBLAS(realtype a, N_Vector x, realtype b, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VConst\_PSBLAS}}] Sets all components of the NVECTOR\_PSBLAS to a constant value and assembles it, the user \textbf{does not need} to assembly it.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VConst_PSBLAS(realtype c, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VProd\_PSBLAS}}] Performs the entry-wise multiplication of two NVECTOR\_PSBLAS, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VProd_PSBLAS(N_Vector x, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VDiv\_PSBLAS}}] Performs the entry-wise division of two NVECTOR\_PSBLAS, the result can be both out-of- and in-place, it does not check for possible zero entries in the denumerator. It is up to the user to guarantee that this does not happens.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDiv_PSBLAS(N_Vector x, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VScale\_PSBLAS}}] Scales an NVECTOR\_PSBLAS by a scalar c, the result can be both out-of- and in-place.
 	 
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VScale_PSBLAS(realtype c, N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VAbs\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the absolute values of the entries of the input.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAbs_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VInv\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the inverse of the entries of the input. It does not check for possible zero entries in the vector. It is up to the user to guarantee that this does not happens.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VInv_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VAddConst\_PSBLAS}}] Adds a scalar to all components of an NVECTOR\_PSBLAS and returns the result in another NVECTOR\_PSBLAS object.
 	 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAddConst_PSBLAS(N_Vector x, realtype b, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VDotProd\_PSBLAS}}] Compute the dot product of two NVECTOR\_PSBLAS objects.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VDotProd_PSBLAS(N_Vector x, N_Vector y)|
 	
 	\item[\fbox{\texttt{N\_VMaxNorm\_PSBLAS}}] Compute the max norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMaxNorm_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNorm\_PSBLAS}}] Compute the weighted (by the size) 2-norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWrmsNorm_PSBLAS(N_Vector x, N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormMask\_PSBLAS}}] Returns the weighted root mean square norm of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| with
 	realtype weight vector \lstinline[style=CStyle]|w| built using only the elements of \lstinline[style=CStyle]|x| corresponding
 	to positive elements of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|id|.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWrmsNormMask_PSBLAS(N_Vector x,N_Vector w,N_Vector id)|
 	
 	\item[\fbox{\texttt{N\_VMin\_PSBLAS}}] Gives back the minimum entry of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMin_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VWL2Norm\_PSBLAS}}] Returns the weighted Euclidean $2$-norm of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| with realtype weight vector \lstinline[style=CStyle]|w|.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWL2Norm_PSBLAS(N_Vector x, N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VL1Norm\_PSBLAS}}] Computes the 1-norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VL1Norm_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VCompare\_PSBLAS}}] Compares the components of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| to the realtype scalar \lstinline[style=CStyle]|c|
 	and returns an NVECTOR\_PSBLAS \lstinline[style=CStyle]|z| such that 
 	\begin{equation*}
 	z_i = \begin{cases}
 	1.0, & |x_i| \geq c,\\
 	0.0, & |x_i| \le c.
 	\end{cases}
 	\end{equation*}
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VCompare_PSBLAS(realtype c, N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VInvTest\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the inverse of the entries of the input. It checks for possible zero entries in the vector. This routine returns a boolean assigned to \lstinline[style=CStyle]|SUNTRUE| if all
 	components of the vector are nonzero (successful inversion) and returns \lstinline[style=CStyle]|SUNFALSE| otherwise.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|booleantype N_VInvTest_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VConstrMask\_PSBLAS}}] Performs the following constraint tests: $x_i > 0$ if $c_i = 2$, $x_i \geq 0$ if $c_i = 1$,
 	$x_i \leq 0$ if $c_i = -1$, $x_i < 0$ if $c_i = -2$. There is no constraint on $x_i$ if $c_i = 0$.
 	This routine returns a boolean assigned to \lstinline[style=CStyle]|SUNFALSE| if any element failed
 	the constraint test and assigned to \lstinline[style=CStyle]|SUNTRUE| if all passed. It also sets a
 	mask vector \lstinline[style=CStyle]|m|, with elements equal to \lstinline[style=CStyle]|1.0| where the constraint test failed,
 	and \lstinline[style=CStyle]|0.0| where the test passed. This routine is used only for constraint
 	checking.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|booleantype N_VConstrMask_PSBLAS(N_Vector c, N_Vector x, N_Vector m)|
 	 
 	\item[\fbox{\texttt{N\_VMinQuotient\_PSBLAS}}] This routine returns the minimum of the quotients obtained by term-wise
 	dividing \lstinline[style=CStyle]|num[i]| by \lstinline[style=CStyle]|denom[i]| . A zero element in \lstinline[style=CStyle]|denom| will be skipped. If no
 	such quotients are found, then the large value \lstinline[style=CStyle]|BIG REAL| (defined in the
 	header file sundials \texttt{types.h}) is returned.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMinQuotient_PSBLAS(N_Vector num, N_Vector denom)|
 	
\end{description}

\subsubsection{Fused operation}
\begin{description}
 	\item[\fbox{\texttt{N\_VLinearCombination\_PSBLAS}}] This routine computes the linear combination of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements
 	\begin{equation*}
 		z_i = \sum_{j=0}^{n_v - 1} c_j x_{j,i}, \qquad i=0,\ldots,n-1
 	\end{equation*}
 	where \lstinline[style=CStyle]|c| is an array of \lstinline[style=CStyle]|nv| scalars, \lstinline[style=CStyle]|X| is an array of NVECTOR\_PSBLAS. When \lstinline[style=CStyle]|z| is one of the vectors in \lstinline[style=CStyle]|X|, then it is assumed to be the first vector in the vector array.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearCombination_PSBLAS(int nvec, realtype* c, N_Vector* V,N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VScaleAddMulti\_PSBLAS}}] This routine scales and adds one vector to \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements:
 	\begin{equation*}
 		z_{j,i} = c_j x_i + y_{j,i}, \qquad j=0,\ldots,n_v-1, \qquad i=0,\ldots,n-1,
 	\end{equation*}
 	where \lstinline[style=CStyle]|c| is an array of \lstinline[style=CStyle]|nv| scalars.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleAddMulti_PSBLAS(int nvec, realtype* a, N_Vector x, N_Vector* Y, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VDotProdMulti\_PSBLAS}}] This routine computes the dot product of a vector with \lstinline[style=CStyle]|nv| other vectors.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VDotProdMulti_PSBLAS(int nvec, N_Vector x,N_Vector *Y, realtype* dotprods)|
 \end{description}
	\subsubsection{Vector array operations}
 \begin{description}
 	\item[\fbox{\texttt{N\_VLinearSumVectorArray\_PSBLAS}}] This routine computes the linear sum of two vector arrays
 	containing \lstinline[style=CStyle]|nv| vectors of \lstinline[style=CStyle]|n| elements:
 	\begin{equation*}
 		z_{j,i} = a x_{j,i} + b y_{j,i}, \qquad i=0,\ldots,n-1, \qquad j=0,\ldots,n_v -1.
 	\end{equation*}
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearSumVectorArray_PSBLAS(int nvec, realtype a, N_Vector* X, realtype b, N_Vector* Y, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VScaleVectorArray\_PSBLAS}}] This routine scales each vector of \lstinline[style=CStyle]|n| elements in a vector
 	array of \lstinline[style=CStyle]|n_v| vectors by a (potentially different) constant:
 	\begin{equation*}
 		z_{j,i} = c_j x_{j,i}, \qquad i=0,\ldots,n-1, \qquad j=0,\ldots,n_v-1.
 	\end{equation*}
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleVectorArray_PSBLAS(int nvec, realtype* c,N_Vector* X, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VConstVectorArray\_PSBLAS}}] This routine sets each element in a vector of \lstinline[style=CStyle]|n|  elements in a vector array of \lstinline[style=CStyle]|nv|  vectors to the same value.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VConstVectorArray_PSBLAS(int nvecs, realtype c,N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormVectorArray\_PSBLAS}}] This routine computes the weighted root mean square
 	norm of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VWrmsNormVectorArray_PSBLAS(int nvecs, N_Vector* X,N_Vector* W, realtype* nrm)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormMaskVectorArray\_PSBLAS}}] This routine computes the masked weighted root mean square norm of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VWrmsNormMaskVectorArray_PSBLAS(int nvec, N_Vector* X,N_Vector* W, N_Vector id,realtype* nrm)|
 	
 	\item[\fbox{\texttt{N\_VScaleAddMultiVectorArray\_PSBLAS}}] This routine scales and adds a vector in a vector array of
 	\lstinline[style=CStyle]|nv| vectors to the corresponding vector in \lstinline[style=CStyle]|ns| vector arrays.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleAddMultiVectorArray_PSBLAS(int nvec, int nsum, realtype* a, N_Vector* X, N_Vector** Y, N_Vector** Z)|
 	
 	\item[\fbox{\texttt{N\_VLinearCombinationVectorArray\_PSBLAS}}] This routine computes the linear combination of \lstinline[style=CStyle]|ns| vector
 	arrays containing \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearCombinationVectorArray_PSBLAS(int nvec, int nsum, realtype* c, N_Vector** X, N_Vector* Z)|
\end{description}

By default all fused and vector array operations are disabled in the nvector PSBLAS module.
The following additional user-callable routines are provided to enable or disable fused and vector
array operations for a specific vector.
\begin{lstlisting}[style=CStyle]
int N_VEnableFusedOps_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearCombination_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleAddMulti_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableDotProdMulti_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearSumVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableConstVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableWrmsNormVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableWrmsNormMaskVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleAddMultiVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearCombinationVectorArray_PSBLAS(N_Vector v,booleantype tf);
\end{lstlisting}

\section{The SUNMATRIX\_PSBLAS implementation}\label{sec:sunmatrix}

The SUNMATRIX\_PSBLAS implementation of the SUNDIALS SUNMATRIX module provides an interface to the PSBLAS code for handling distributed sparse matrices. 
It defines the \emph{content} field of \texttt{SUNMATRIX} to be a structure containing the PSBLAS descriptor for the data distribution, a PSBLAS sparse matrix object of double, and the PSBLAS communicator (context).

\begin{lstlisting}[style=CStyle]
struct _SUNMatrixContent_PSBLAS {
 psb_c_descriptor *cdh;       /* descriptor for data distribution */
 psb_c_dspmat  *ah;           /* PSBLAS sparse matrix             */
 int ictxt;                   /* PSBLAS communicator              */
};
\end{lstlisting}

\attention All the matrices that have to interact needs to be instantiated on the same parallel context \lstinline[style=CStyle]|ictxt|, and on the same data distribution \lstinline[style=CStyle]|cdh|, and this holds also for the vectors for the mixed type operation.


The header file to include when using this module is \texttt{sunmatrix\_psblas.h}. The installed module library to link to is \texttt{libsundials\_sunmatrixpsblas.a} where \texttt{.lib} is typically \texttt{.so} for shared libraries and \texttt{.a} for static libraries.

\subsection{SUNMATRIX\_PSBLAS accessor macros}

The following macros are provided to access the content of a SUNMATRIX\_PSBLAS matrix. The suffix \texttt{\_P} in the names denotes the fact that the data are in distributed memory.

\begin{lstlisting}[style=CStyle]
#define SM_CONTENT_P(A)     ( (SUNMatrixContent_PSBLAS)(A->content) )
#define SM_DESCRIPTOR_P(A)  ( SM_CONTENT_P(A)->cdh )
#define SM_PMAT_P(A)        ( SM_CONTENT_P(A)->ah )
#define SM_ICTXT_P(A)       ( SM_CONTENT_P(A)->ictxt )
\end{lstlisting}

\marginlabel{\lstinline[style=CStyle]|SM_CONTENT_P(A)|} this macro gives access to the contents of the PSBLAS matrix \texttt{SUNMATRIX}.

\marginlabel{\lstinline[style=CStyle]|SM_DESCRIPTOR_P(A),SM_PMAT_P(A)|} these macros give instead individual access to the parts of the content of a PSBLAS parallel \texttt{SUNMATRIX}.

\marginlabel{\lstinline[style=CStyle]|SM_CONTENT_P(A)|} this macro provides the PSBLAS context used by the SUNMATRIX\_PSBLAS sparse matrices.

In PSBLAS every sparse matrix has an associated state, which can take one of the following
values:
\begin{description}
\item[BUILD] is the state entered after the first allocation, and before the first assembly; in
this state it is possible to add nonzero entries.
\item[ASSEMBLED] is the state entered after the assembly; computations using the sparse
matrix, such as matrix-vector products, are only possible in this state;
\item[UPDATE] state entered after a reinitalization; this is used to handle applications
in which the same sparsity pattern is used multiple times with different
coefficients. \attention In this state \textit{it is only possible to enter coefficients for already
existing nonzero entries}.
\end{description}

\subsection{SUNMATRIX\_PSBLAS functions}

The SUNMATRIX\_PSBLAS implementation provides PSBLAS implementations of all the sparse matrix operations listed in Table~7.2 of the original KINSOL library~\cite{kinsolguide}. Following the standard nomenclature of the SUNDIALS library, their names are obtained from the ones listed in Table~7.2 by appending the suffix \texttt{\_PSBLAS}. The SUNMATRIX\_PSBLAS implementation provides the following additional user--callable routines

\begin{description}
	\item[\fbox{\texttt{SUNMatAsb\_PSBLAS}}] This routine assemble the SUNMATRIX after that all the elements have been inserted into it, i.e., after that all the calls to the \texttt{SUNMatIns\_PSBLAS} routine have been completed. This is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dspasb|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatAsb_PSBLAS(SUNMatrix A);|
	
	\item[\fbox{\texttt{SUNMatIns\_PSBLAS}}] This routine inserts a set of coefficients into a sparse matrix. On entry to this routine the descriptor may be in either the BUILD or ASSEMBLED state, while the sparse matrix may be in either the BUILD or UPDATE state. We stress that it mandatory that if the descriptor is in the BUILD state, then also the sparse matrix \textit{must} be in
	the BUILD state, since adding entries to the matrix causes internal calls altering the structure of the communication pattern for the distributed object. The insert of the element in the matrix si assumed to be in the COO format, thus the coefficients to be inserted are represented by the ordered triples \lstinline[style=CStyle]|irw[i]|, \lstinline[style=CStyle]|icl[i]|, \lstinline[style=CStyle]|val[i]|, for $i = 1,\ldots,\lstinline[style=CStyle]|nz|$; these triples should belong to the current process, i.e., the index \lstinline[style=CStyle]|irw[i]| should be one of the local indices, but are otherwise arbitrary, it this is not the case any coefficients from matrix rows not owned by the calling process are
	silently ignored.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatIns_PSBLAS(psb_i_t nz, const psb_l_t *irw, const psb_l_t *icl, const psb_d_t *val,SUNMatrix A);|
\end{description}

\subsubsection{Description of the SUNMATRIX\_PSBLAS functions}

\begin{description}
\item[\fbox{\texttt{SUNPSBLASMatrix}}] Define and implement user-callable constructor routines to create a
SUNMatrix on the PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh|, and with the content field and ops pointing to the matrix operations defined in the following. The matrix is initialized in the BUILD state.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNMatrix SUNPSBLASMatrix(int ictxt, psb_c_descriptor *cdh)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_Print}}] This function prints the content of a dense SUNMatrix in MatrixMarket format to file specified by \texttt{filename}, the routine takes care of creating/opening the file, a separated one for each process in which the local part (without any eventual overlap) is printed.
 
\marginlabel{Prototype} \lstinline[style=CStyle]|void SUNPSBLASMatrix_Print(SUNMatrix A,char *matrixtitle,char *filename)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_Rows}}] This function returns the number of (global) rows in the PSBLAS SUNMatrix.

\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype SUNPSBLASMatrix_Rows(SUNMatrix A)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_Columns}}] This function returns the number of (global) columns in the PSBLAS SUNMatrix.

\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype SUNPSBLASMatrix_Columns(SUNMatrix A)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_NNZ}}] This function returns the (global) number of non-zero entries in the PSBLAS SUNMatrix.

\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype SUNPSBLASMatrix_NNZ(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatGetID\_PSBLAS}}] Returns the type identifier for the matrix \texttt{A}, since this is a custom implementation it returns the value \texttt{SUNMATRIX\_CUSTOM}.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNMatrix_ID SUNMatGetID_PSBLAS(SUNMatrix A)| 

\item[\fbox{\texttt{SUNMatClone\_PSBLAS}}] Creates a new SUNMatrix on the same descriptor of an existing matrix \texttt{A} and sets
the \texttt{ops} field. It \textbf{does not copy} the matrix, but rather allocates storage for the new matrix leaving the new matrix in the BUILD state.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNMatrix SUNMatClone_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatDestroy\_PSBLAS}}] Destroys the SUNMatrix \texttt{A} and frees memory allocated for its internal data. This routine \textbf{does not free} the communicator, in general there are many objects insisting on the same communicator, therefore it should be destroyed/freed on its own.

\marginlabel{Prototype} \lstinline[style=CStyle]|void SUNMatDestroy_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatZero\_PSBLAS}}] Performs the operation $(A)_{i,j} = 0$ for all entries of the matrix \texttt{A}. The return value is an integer flag denoting success/failure of the operation. The PSBLAS at the end of this operation is left in the UPDATE state.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatZero_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatCopy\_PSBLAS}}] Performs the operation $(B)_{i,j} = (A)_{ i,j}$ for all entries of the matrices \texttt{A} and \texttt{B}. The return value is an integer flag denoting success/failure of the operation. The matrix \texttt{B} inherits the state of the matrix \texttt{A}.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatCopy_PSBLAS(SUNMatrix A, SUNMatrix B)|

\item[\fbox{\texttt{SUNMatScaleAdd\_PSBLAS}}] Performs the operation $A = cA + B$. The return value is an integer flag denoting success/failure of the operation. This function assumes that both the matrices are defined on the same communicator.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatScaleAdd_PSBLAS(realtype c, SUNMatrix A, SUNMatrix B)|

\item[\fbox{\texttt{SUNMatScaleAddI\_PSBLAS}}] Performs the operation $A = cA + I$. The return value is an integer flag denoting success/failure of the operation. 

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatScaleAddI_PSBLAS(realtype c, SUNMatrix A)|

\item[\fbox{\texttt{SUNMatMatvec\_PSBLAS}}] Performs the matrix-vector product operation, $\mathbf{y} = A\mathbf{x}$. It should only be
called with vectors $\mathbf{x}$ and $\mathbf{y}$ that are compatible with the matrix $A$, i.e., they should be both defined on the same communicator and have the same dimensions. The return value is an integer flag denoting
success/failure of the operation.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatMatvec_PSBLAS(SUNMatrix A, N_Vector x, N_Vector y)|

\item[\fbox{\texttt{SUNMatSpace\_PSBLAS}}] This function is advisory only, for use in determining a user's total space requirements, for this module it is a dummy function always returning true.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatSpace_PSBLAS(SUNMatrix A, long int *lenrw, long int *leniw)|
\end{description}

\subsubsection{An example of matrix assembly}

As an example of usage of this matrix routines we consider the same boundary value problem in~\eqref{eq:boundaryproblem}, to build the matrix $A$ associated to the centered finite difference discretization
\begin{equation}
	\ldots
\end{equation}
To this end we use the same communicator \texttt{cdh} and context \texttt{ictxt} we have allocated in Listing~\ref{lst:example_of_allocation}, by simply doing:
\begin{lstlisting}[style=CStyle]
A = SUNPSBLASMatrix(ictxt, cdh);
matgen(ictxt, nl, idim, vl,A);
psb_c_cdasb(cdh);
SUNMatAsb_PSBLAS(A);
\end{lstlisting}
We have firs initialized the sparse PSBLAS matrix inside the SUNMATRIX container, then by using the \texttt{matgen} allocation routine in Listing~\ref{lst:allocationroutine} we have populate the sparse matrix, and finally assembled both the descriptor, and the sparse matrix.

The complete example can be found in \texttt{examples/sunmatrix/psblas}.

\section{The SUNLINSOL\_PSBLAS implementation}\label{sec:sunlinsol}

\subsection{Algebraic Multigrid Preconditioners}

\appendix

\section{Matrix assembly routine}
The following routine loops through the local entries of the communicator allocate in Listing~\ref{lst:example_of_allocation}, and uses the \texttt{SUNMatIns\_PSBLAS} routine to insert the entries in the sparse matrix. The auxiliary functions $\{a_{i},b_i,g\}_{i=1}^3$ take care of the coefficient functions in~\eqref{eq:boundaryproblem}.
\begin{lstlisting}[style=CStyle,caption="Allocation routine for the discrete boundary value problem~\eqref{eq:boundaryproblem}.",label=lst:allocationroutine]
psb_i_t matgen(psb_i_t ictxt, psb_i_t nl, psb_i_t idim, psb_l_t vl[],SUNMatrix A)
{
psb_i_t iam, np;
psb_l_t ix, iy, iz, el,glob_row;
psb_i_t i, k, info;
double x, y, z, deltah, sqdeltah, deltah2;
double val[10*NBMAX], zt[NBMAX];
psb_l_t irow[10*NBMAX], icol[10*NBMAX];

info = 0;
psb_c_info(ictxt,&iam,&np);
deltah = (double) 1.0/(idim+1);
sqdeltah = deltah*deltah;
deltah2  = 2.0* deltah;
psb_c_set_index_base(0);
for (i=0; i<nl;  i++) {
glob_row=vl[i];
el=0;
ix = glob_row/(idim*idim);
iy = (glob_row-ix*idim*idim)/idim;
iz = glob_row-ix*idim*idim-iy*idim;
x=(ix+1)*deltah;
y=(iy+1)*deltah;
z=(iz+1)*deltah;
zt[0] = 0.0;
/*  internal point: build discretization */
/*  term depending on   (x-1,y,z)        */
val[el] = -a1(x,y,z)/sqdeltah-b1(x,y,z)/deltah2;
if (ix==0) {
zt[0] += g(0.0,y,z)*(-val[el]);
} else {
icol[el]=(ix-1)*idim*idim+(iy)*idim+(iz);
el=el+1;
}
/*  term depending on     (x,y-1,z) */
val[el]  = -a2(x,y,z)/sqdeltah-b2(x,y,z)/deltah2;
if (iy==0) {
zt[0] += g(x,0.0,z)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy-1)*idim+(iz);
el=el+1;
}
/* term depending on     (x,y,z-1)*/
val[el]=-a3(x,y,z)/sqdeltah-b3(x,y,z)/deltah2;
if (iz==0) {
zt[0] += g(x,y,0.0)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy)*idim+(iz-1);
el=el+1;
}
/* term depending on     (x,y,z)*/
val[el]=2.0*(a1(x,y,z)+a2(x,y,z)+a3(x,y,z))/sqdeltah + c(x,y,z);
icol[el]=(ix)*idim*idim+(iy)*idim+(iz);
el=el+1;
/*  term depending on     (x,y,z+1) */
val[el] = -a3(x,y,z)/sqdeltah+b3(x,y,z)/deltah2;
if (iz==idim-1) {
zt[0] += g(x,y,1.0)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy)*idim+(iz+1);
el=el+1;
}
/* term depending on     (x,y+1,z) */
val[el] = -a2(x,y,z)/sqdeltah+b2(x,y,z)/deltah2;
if (iy==idim-1) {
zt[0] += g(x,1.0,z)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy+1)*idim+(iz);
el=el+1;
}
/*  term depending on     (x+1,y,z) */
val[el] = -a1(x,y,z)/sqdeltah+b1(x,y,z)/deltah2;
if (ix==idim-1) {
zt[0] += g(1.0,y,z)*(-val[el]);
} else {
icol[el]=(ix+1)*idim*idim+(iy)*idim+(iz);
el=el+1;
}
for (k=0; k<el; k++) irow[k]=glob_row;
if ((info=SUNMatIns_PSBLAS(el,irow,icol,val,A))!=0)
fprintf(stderr,"From psb_c_dspins: %d\n",info);
}

return(info);
}
\end{lstlisting}

Observe that to speed-up the insertion procedure we are collecting together a certain number of rows to be inserted, specifically \texttt{10*NBMAX} for a defined value of NBMAX. It is clearly possible to execute one call for
each nonzero coefficient, however this would have a substantial computational
overhead. Therefore packing a ``certain amount of data'' (\texttt{10*NBMAX}) into each call
to the insertion routine is advisable. The best performing value of \texttt{NBMAX} depends on both the architecture of the computer being used and
on the problem structure.

\printbibliography

\end{document}
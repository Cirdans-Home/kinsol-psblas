\documentclass[twoside,a4paper]{refart}

\usepackage[utf8]{inputenc}
\usepackage{ae}
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dirtree}
\usepackage{booktabs}

\usepackage{array,lipsum}

\newenvironment{fulltable}[1][tbp]
{\begin{table}[#1]%
		\hspace*{-\leftmarginwidth}%
		\begin{minipage}{\fullwidth}}
		{\end{minipage}\end{table}}

\theoremstyle{definition}
\newtheorem{exmp}{Example}

\title{PSBLAS-KINSOL interface\thanks{Work supported by the EC under the Horizon 2020 Project ``Energy oriented Centre of Excellence for computing applications'' (EoCoE II), Project ID: 824158}}
\author{Istituto per le Applicazioni del Calcolo ``M. Picone'',\\
	Consiglio Nazionale delle Ricerche \\
	Pasqua D'Ambra \\
	Fabio Durastante \\
	Salvatore Filippone \\
	PSBLAS 3.6.1 --- Kinsol Interface Version 1}
\date{\today}
\emergencystretch1em

\setcounter{tocdepth}{2}
\settextfraction{0.7}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstdefinestyle{CStyle}{
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,
	breaklines=true,
	captionpos=b,
	keepspaces=true,
%	numbers=left,
	numbersep=5pt,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=2,
	language=C,
	morekeywords={N_Vector,sunindextype,psb_i_t,psb_c_descriptor,psb_c_dvector,booleantype,psb_c_info,psb_c_init,psb_cdall,psb_c_cdall_vl,psb_l_t}
}

\usepackage[backend=biber]{biblatex}
\bibliography{bibliography}

\begin{document}
	\maketitle
	
	\tableofcontents
	\newpage
	
	\section{The logic behind a PSBLAS instrumented application}
	
\marginlabel{
\textit{Library structure}
\begin{minipage}{0.9\textwidth}
\dirtree{%
 .1 kinsol-psblas.
 .2 config.
 .2 doc.
 .2 examples.
 .2 include.
 .2 src.
 .2 test.
}
\end{minipage}
}	The main aim of the PSBLAS library is the parallel implementation of iterative solvers
	for sparse linear systems,
	\begin{equation}\label{eq:linear_system}
		A \mathbf{x} = \mathbf{b}, \qquad A \in \mathbb{K}^{n \times n}, \qquad \mathbb{K} = \mathbb{R}, \mathbb{C},
	\end{equation}
	through the distributed memory paradigm operating with message
	passing. The library includes all the needed routines for this task, e.g, functions for multiplying sparse matrices by dense matrices, for solving block diagonal systems with triangular diagonal entries or for preprocessing sparse matrices.
	
	The pivotal choice to be made in this setting regards the distribution of the coefficient matrix $A$ for the linear system~\eqref{eq:linear_system}. In PSBLAS this choice is based on the \textbf{owner computes rule}: \marginlabel{\textbf{Owner computes rule}} each unknown is assigned to a process that will  own the corresponding row in the coefficient matrix and
	will  carry out all related computations.
	
	If $A$ is obtained from the discretization of a Partial Differential Equation (PDE), this allocation strategy is equivalent to the choice of a partition of the mesh into {\em
		sub-domains}.
	
	\attention PSBLAS supports \emph{any} distribution that keeps together
	the coefficients of each matrix row there are \textbf{no other} constraints on
	the variable assignment.
	
	Any PSBLAS application will always start with the construction of the parallel environment, i.e., of an MPI (virtual) parallel machine, that we call here context by means of the \lstinline[style=CStyle]|psb_c_init| function~as
\begin{lstlisting}[style=CStyle]
psb_i_t ictxt, iam, np;
ictxt = psb_c_init();
psb_c_info(ictxt,&iam,&np);
\end{lstlisting}
	that creates a parallel environment on \lstinline[style=CStyle]|np| processors $0,\ldots,\lstinline[style=CStyle]|np|-1$, of which we are process \lstinline[style=CStyle]|iam|.
	
\begin{description}
	\item[\fbox{psb\_c\_init}] this subroutine initializes the PSBLAS parallel environment, defining a virtual parallel machine, the value \texttt{ictxt} in out is the communication context identifying the virtual parallel machine.
	This is always a duplicate of \texttt{basectxt}, so that library communications are completely separated from other communication operations
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_i_t psb_c_init();|
	
	\item[\fbox{psb\_c\_info}] this subroutine returns information about the PSBLAS parallel environment, defining a virtual parallel machine that is identified by the value \texttt{ictxt}. The values on return are the identifier of current process in the PSBLAS virtual parallel machine (\texttt{iam}), and the number of processes in the PSBLAS virtual parallel machine~(\texttt{np})
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_i_t psb_c_info(psb_i_t ictxt,psb_i_t *iam,psb_i_t *np);|
	
\end{description}	
	
	The next step is represented by the need of subdividing the index space among processes, and this creates a mapping from the ``global'' numbering $1,\ldots,n$ to a ``local'' numbering
	in each process. This means that each process $i$ will own a certain subset
	$1,\ldots,n_{\hbox{row}_i}$, each element of which corresponds to a certain element of $1\dots n$.
	
	Therefore, after the initialization the first step is to establish an index space, and
	this is done with a call to one of the variants of the \lstinline[style=CStyle]|psb_cdall| function to allocate a descriptor object \lstinline[style=CStyle]|psb_c_descriptor|:
\begin{description}
	\item[\fbox{\texttt{psb\_c\_cdall\_vg}}] the association between an index and a process is specified via an integer vector \lstinline[style=CStyle]|vg[]|, each index $i \in \{1,\ldots,\lstinline[style=CStyle]|ng|\}$ is assigned to process \lstinline[style=CStyle]|vg[i]|. The vector \lstinline[style=CStyle]|vg[]| must be identical on all calling processes, and its entries have the ranges $(0,\ldots,\lstinline[style=CStyle]|np|-1)$ or
	$(1,\ldots,\lstinline[style=CStyle]|np|)$ according to the fact that \lstinline[style=CStyle]|psb_c_set_index_base(0)| or \lstinline[style=CStyle]|psb_c_set_index_base(1)| has been called at the beginning. The size \lstinline[style=CStyle]|ng| is specified one can chose to use the entire
	vector \lstinline[style=CStyle]|vg[]|, thus having \lstinline[style=CStyle]|vg[ng]|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_vg(psb_l_t ng,psb_i_t *vg,psb_i_t ictxt,psb_c_descriptor *cdh);|
	\item[\fbox{\texttt{psb\_c\_cdall\_vl}}] the association is done by specifying the list of indices \lstinline[style=CStyle]|vl[nl]| assigned to
	the current process; thus, the global problem size \lstinline[style=CStyle]|nl| is given by
	the range of the aggregate of the individual vectors \lstinline[style=CStyle]|vl[]| specified in
	the calling processes. The subroutine will check how
	many times each entry in the global index space $(1,\ldots,\lstinline[style=CStyle]|nl|)$ is specified
	in the input lists \lstinline[style=CStyle]|vl[]|, therefore it allows for the presence of overlap in the
	input, and checks for the ``orphan'' indices.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_vl(psb_i_t nl,psb_l_t *vl,psb_i_t ictxt,psb_c_descriptor *cdh);|
	\item[\fbox{\texttt{psb\_c\_cdall\_nl}}] produces a generalized block-row distribution of the number of indices belonging to the current process in which each process $i$ gets assigned
	a consecutive chunk of $nl$ global indices,
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_nl(psb_i_t nl,psb_i_t ictxt, psb_c_descriptor *cdh);|
\end{description}
	for the case of a simple minded block distribution, i.e., the index space is first numbered sequentially in a standard way, then the corresponding vector is distributed according to a block distribution directive.
	%The discretization ensures there are IDIM *internal* points in each direction.
	
\begin{exmp}\label{ex:the_example}
We consider as example the finite difference discretization of the following boundary value problem
\begin{equation}\label{eq:boundaryproblem}
	- \frac{b_1 \partial^2 u}{\partial x^2} - \frac{b_2 \partial^2 u}{\partial y^2} - \frac{b_3 \partial^2 u}{\partial z^2} + \frac{a_1 \partial u}{\partial x} + \frac{a_2 \partial u}{\partial y} + a_3 \frac{a_3 \partial u}{\partial z} = 0,
\end{equation}
for $(x,y,z) \in [0,1]^3$, with Dirichlet boundary conditions, on a uniform grid with \lstinline[style=CStyle]|idim| node per size. All the allocation procedure can be expressed as
\begin{lstlisting}[style=CStyle,caption="Example of allocation procedure for a 3D block data distribution",label=lst:example_of_allocation]
psb_c_descriptor *cdh;
psb_i_t idim,nb,nlr, nl;
psb_l_t i,ng, *vl, k;

cdh=psb_c_new_descriptor();
psb_c_set_index_base(0);

/* Simple minded BLOCK data distribution */
ng = ((psb_l_t) idim)*idim*idim;
nb = (ng+np-1)/np;
nl = nb;
if ( (ng -iam*nb) < nl) nl = ng -iam*nb;
fprintf(stderr,"%d: Input data %d %ld %d %d\n",iam,idim,ng,nb, nl);
if ((vl=malloc(nb*sizeof(psb_l_t)))==NULL) {
	fprintf(stderr,"On %d: malloc failure\n",iam);
	psb_c_abort(ictxt);
}
i = ((psb_l_t)iam) * nb;
for (k=0; k<nl; k++)
	vl[k] = i+k;
psb_c_cdall_vl(nl,vl,ictxt,cdh);
\end{lstlisting}
\end{exmp}

	Now that the initial distribution of the index space has been performed, we need to allocate  dense vectors and sparse matrices on such index space, and thus we define the complete topology of our computational problem. Since our task is to use the capabilities of SUNDIALS-KINSOL to solve for nonlinear problems, here lies the core of the interfacing between the two codes.

	Before the termination of the program, \textit{after} having freed/destroyed all the objects instantiated on the descriptor \texttt{cdh}, you need also to free the memory occupied by it, and the to terminate the parallel environment. This is achieved by means of the following routines.
	\begin{description}
		\item[\fbox{\texttt{psb\_c\_cdfree}}] frees a communication descriptor
		
		\marginlabel{Prototype} \lstinline[style=CStyle]|psb_i_t psb_c_cdfree(psb_c_descriptor *cdh)|;
		
		\item[\fbox{\texttt{psb\_c\_exit}}] this subroutine exits from the PSBLAS parallel virtual machine, observe that this routine may be called even if a previous call to \lstinline[style=CStyle]|psb_info| has returned with \lstinline[style=CStyle]|iam=-1|.
		
		\marginlabel{Prototype} \lstinline[style=CStyle]|psb_i_t psb_c_exit(psb_i_t ictxt);|
		
		\item[\fbox{\texttt{psb\_c\_abort}}] this subroutine aborts computation on the parallel virtual machine, and can be used when error that needs the program to fail occurs.
		
		\marginlabel{Prototype} \lstinline[style=CStyle]|psb_i_t psb_c_abort(psb_i_t ictxt);| 		
		
	\end{description}


	
	In the next two Sections~\ref{sec:nvector}, and Section~\ref{sec:sunmatrix} we describe such encapsulation for dense vector, and sparse matrices. Then in Section~\ref{sec:sunlinsol} we describe the interfacing with the \textbf{linear solvers} and \textbf{preconditioners}

	Complete information on the PSBLAS data structures, and functions that are mentioned along the text can be found in~\cite{psblasguide}.
	
	
	\section{The NVECTOR\_PSBLAS implementation}\label{sec:nvector}
\marginlabel{
\textit{Library structure}
\begin{minipage}{0.9\textwidth}
\dirtree{%
 .1 kinsol-psblas.
 .2 config.
 .2 doc.
 .2 examples.
 .3 nvector.
 .4 psblas.
 .2 include.
 .3 nvector.
 .2 src.
 .3 nvector.
 .4 psblas.
 .2 test.
}
\end{minipage}
}	The NVECTOR\_PSBLAS implementation of the SUNDIALS NVECTOR module provides an interface to the PSBLAS code for handling distributed dense vectors.
	It defines the \emph{content} field of \texttt{N\_Vector} to be a structure containing the PSBLAS descriptor for the data distribution, a PSBLAS vector of double, and the PSBLAS communicator (context).
	
\begin{lstlisting}[style=CStyle]
struct _N_VectorContent_PSBLAS {
	booleantype own_data;  /*ownership of data*/
	psb_c_descriptor *cdh; /*descriptor for data distribution*/
	psb_c_dvector *pvec;   /*PSBLAS vector*/
	int ictxt;             /*PSBLAS communicator*/
};
\end{lstlisting}
	
	\attention All the vectors that have to interact needs to be instantiated on the same parallel context \lstinline[style=CStyle]|ictxt|, and on the same data distribution \lstinline[style=CStyle]|cdh|.
	
	
	The header file to include when using this module is \texttt{nvector\_psblas.h}. The installed module library to link to is \texttt{sundials\_nvecpsblas.lib} where \texttt{.lib} is typically \texttt{.so} for shared libraries and \texttt{.a} for static libraries.
	
	\subsection{NVECTOR\_PSBLAS accessor macros}
	
	The following macros are provided to access the content of a NVECTOR\_PSBLAS vector. The suffix \texttt{\_P} in the names denotes the fact that the data are in distributed memory.

\begin{lstlisting}[style=CStyle]
#define NV_CONTENT_P(v)   ((N_VectorContent_PSBLAS)(v->content))
#define NV_DESCRIPTOR_P(v)(NV_CONTENT_P(v)->cdh)
#define NV_OWN_DATA_P(v)  (NV_CONTENT_P(v)->own_data)
#define NV_PVEC_P(v)      (NV_CONTENT_P(v)->pvec)
#define NV_ICTXT_P(v)     (NV_CONTENT_P(v)->ictxt)
\end{lstlisting}

\marginlabel{\lstinline[style=CStyle]|NV_CONTENT_P(v)|} this macro gives access to the contents of the PSBLAS vector \texttt{N\_Vector}.

\marginlabel{\lstinline[style=CStyle]|NV_DESCRIPTOR_P(v),NV_OWN_DATA_P(v),NV_PVEC_P(v)|} these macros give instead individual access to the parts of the content of a PSBLAS parallel \texttt{N\_Vector}.

\marginlabel{\lstinline[style=CStyle]|NV_ICTXT_P(v)|} this macro provides the PSBLAS context used by the NVECTOR\_PSBLAS vectors.

\subsection{NVECTOR\_PSBLAS functions}

The NVECTOR\_PSBLAS implementation provides PSBLAS implementations of all the vectors operations listed in Tables~6.2, 6.3, and 6.4 of the original KINSOL library~\cite{kinsolguide}. Following the standard nomenclature of the SUNDIALS library, their names are obtained from the ones listed in Tables~6.2, 6.3, and 6.4 by appending the suffix \texttt{\_PSBLAS}. The NVECTOR\_PSBLAS implementation provides the following additional user--callable routine:

\begin{description}
	\item[\fbox{\texttt{N\_VAsb\_PSBLAS}}] This routine assemble the NVector after that all the elements have been inserted into it, i.e., after that all the calls to the \texttt{N\_VMake\_PSBLAS} routine have been completed. This is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dgeasb|.

	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAsb_PSBLAS(N_Vector v)|
\end{description}

\subsubsection{Description of the NVECTOR\_PSBLAS functions}

\begin{description}
	\item[\fbox{\texttt{N\_VNew\_PSBLAS}}] This function creates and allocates memory for a parallel vector
	on the PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh|
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VNew_PSBLAS(int ictxt, psb_c_descriptor *cdh);|
	
	\item[\fbox{\texttt{N\_VNewEmpty\_PSBLAS}}] This function creates a new PSBLAS vector with empty data array.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VNewEmpty_PSBLAS(int ictxt, psb_c_descriptor *cdh);|
	
	\item[\fbox{\texttt{N\_VMake\_PSBLAS}}] Function to create a PSBLAS \texttt{N\_Vector} with user data component. This function is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dgeins|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VMake_PSBLAS(int ictxt, psb_c_descriptor *cdh,psb_i_t m, psb_i_t *irow,double *val);|
	
	The PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh| are the one defined for the whole programs, the integer \lstinline[style=CStyle]{m} is the number of rows in \lstinline[style=CStyle]{val[]} to be inserted, the array of integers \lstinline[style=CStyle]{irow} is the indices of the rows to be inserted. Specifically, row \lstinline[style=CStyle]|i| of \lstinline[style=CStyle]|val| will be inserted into the local row corresponding to the global index row index \lstinline[style=CStyle]|row[i]|.
	
	\attention This routine does not assemble the final vector. After the insertion of all the elements has been completed then the vector should be assembled by means of the \texttt{N\_VAsb\_PSBLAS} routine.
	
	\item[\fbox{\texttt{N\_VCloneVectorArray\_PSBLAS}}] This function creates an array of new parallel vectors (by cloning) an array of \lstinline[style=CStyle]|count| parallel vectors \lstinline[style=CStyle]|v|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector *N_VCloneVectorArray_PSBLAS(int count, N_Vector w)|
	
	\item[\fbox{\texttt{N\_VCloneVectorArrayEmpty\_PSBLAS}}] This function creates an array of \lstinline[style=CStyle]|count| new parallel vectors with empty data array on the same communicator and context of the vector \lstinline[style=CStyle]|w|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector *N_VCloneVectorArrayEmpty_PSBLAS(int count, N_Vector w)|
	
	\item[\fbox{\texttt{N\_VDestroyVectorArray\_PSBLAS}}] This function to frees an array of \lstinline[style=CStyle]|count| \texttt{N\_Vector}s created with \texttt{N\_VCloneVectorArray\_PSBLAS}
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDestroyVectorArray_PSBLAS(N_Vector *vs, int count)|
	
	\item[\fbox{\texttt{N\_VGetLength\_PSBLAS}}] This function returns the \emph{global} vector length, this is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_cd_get_global_rows|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype N_VGetLength_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VGetLocalLength\_PSBLAS}}] This function returns the \emph{local} vector length, this is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_cd_get_local_rows|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype N_VGetLocalLength_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VPrint\_PSBLAS}}] This function prints the local data in a parallel vector to \lstinline[style=CStyle]|stdout|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VPrint_PSBLAS(N_Vector x)|
	
	\item[\fbox{\texttt{N\_VPrintFile\_PSBLAS}}] This function prints the local data in a parallel vector to \lstinline[style=CStyle]|outfile|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VPrintFile_PSBLAS(N_Vector x, FILE* outfile)|
	
	\item[\fbox{\texttt{N\_VGetVectorID\_PSBLAS}}] This function returns the SUNDIALS identificative for the PSBLAS vector, since this is a custom implementation it returns the integer constant \lstinline[style=CStyle]|SUNDIALS_NVEC_CUSTOM|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector_ID N_VGetVectorID_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VCloneEmpty\_PSBLAS}}] Clones a NVECTOR\_PSBLAS with a \lstinline[style=CStyle]|NULL| \lstinline[style=CStyle]|pvec| field, and with value \lstinline[style=CStyle]|SUNFALSE| in the \lstinline[style=CStyle]|own_data| field.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VCloneEmpty_PSBLAS(N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VClone\_PSBLAS}}] Clones a NVECTOR\_PSBLAS allocating its memory following the same communicator of the cloned one.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VClone_PSBLAS(N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VDestroy\_PSBLAS}}] Destroys a NVECTOR\_PSBLAS freeing both the memory allocated for the corresponding PSBLAS vector, and the memory allocated for the NVECTOR\_PSBLAS structure.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDestroy_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VSpace\_PSBLAS}}] Returns storage requirements for one NVECTOR\_PSBLAS. \lstinline[style=CStyle]|lrw| contains the number of realtype words and \lstinline[style=CStyle]|liw| contains the number of integer words.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VSpace_PSBLAS(N_Vector v, sunindextype *lrw,sunindextype *liw)|
 	
 	\item[\fbox{\texttt{N\_VGetArrayPointer\_PSBLAS}}] Returns a pointer to a realtype array from the NVECTOR\_PSBLAS, this is the local portion of the distributed PSBLAS vector encapsulated in the \texttt{N\_Vector} object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype *N_VGetArrayPointer_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VSetArrayPointer\_PSBLAS}}] This function is a dummy function, in PSBLAS we use \lstinline[language=Fortran]|allocatable| objects for the local part of the distributed vector, and, moreover, we assume having an arbitrary distribution of the indexes.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VSetArrayPointer_PSBLAS(psb_c_dvector *v_data, N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VLinearSum\_PSBLAS}}] Performs the AXPBY BLAS operation between to  NVECTOR\_PSBLAS, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VLinearSum_PSBLAS(realtype a, N_Vector x, realtype b, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VConst\_PSBLAS}}] Sets all components of the NVECTOR\_PSBLAS to a constant value and assembles it, the user \textbf{does not need} to assembly it.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VConst_PSBLAS(realtype c, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VProd\_PSBLAS}}] Performs the entry-wise multiplication of two NVECTOR\_PSBLAS, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VProd_PSBLAS(N_Vector x, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VDiv\_PSBLAS}}] Performs the entry-wise division of two NVECTOR\_PSBLAS, the result can be both out-of- and in-place, it does not check for possible zero entries in the denumerator. It is up to the user to guarantee that this does not happens.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDiv_PSBLAS(N_Vector x, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VScale\_PSBLAS}}] Scales an NVECTOR\_PSBLAS by a scalar c, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VScale_PSBLAS(realtype c, N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VAbs\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the absolute values of the entries of the input.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAbs_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VInv\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the inverse of the entries of the input. It does not check for possible zero entries in the vector. It is up to the user to guarantee that this does not happens.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VInv_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VAddConst\_PSBLAS}}] Adds a scalar to all components of an NVECTOR\_PSBLAS and returns the result in another NVECTOR\_PSBLAS object.
 	 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAddConst_PSBLAS(N_Vector x, realtype b, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VDotProd\_PSBLAS}}] Compute the dot product of two NVECTOR\_PSBLAS objects.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VDotProd_PSBLAS(N_Vector x, N_Vector y)|
 	
 	\item[\fbox{\texttt{N\_VMaxNorm\_PSBLAS}}] Compute the max norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMaxNorm_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNorm\_PSBLAS}}] Compute the weighted (by the size) 2-norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWrmsNorm_PSBLAS(N_Vector x, N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormMask\_PSBLAS}}] Returns the weighted root mean square norm of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| with
 	realtype weight vector \lstinline[style=CStyle]|w| built using only the elements of \lstinline[style=CStyle]|x| corresponding
 	to positive elements of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|id|.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWrmsNormMask_PSBLAS(N_Vector x,N_Vector w,N_Vector id)|
 	
 	\item[\fbox{\texttt{N\_VMin\_PSBLAS}}] Gives back the minimum entry of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMin_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VWL2Norm\_PSBLAS}}] Returns the weighted Euclidean $2$-norm of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| with realtype weight vector \lstinline[style=CStyle]|w|.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWL2Norm_PSBLAS(N_Vector x, N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VL1Norm\_PSBLAS}}] Computes the 1-norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VL1Norm_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VCompare\_PSBLAS}}] Compares the components of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| to the realtype scalar \lstinline[style=CStyle]|c|
 	and returns an NVECTOR\_PSBLAS \lstinline[style=CStyle]|z| such that
 	\begin{equation*}
 	z_i = \begin{cases}
 	1.0, & |x_i| \geq c,\\
 	0.0, & |x_i| \le c.
 	\end{cases}
 	\end{equation*}
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VCompare_PSBLAS(realtype c, N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VInvTest\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the inverse of the entries of the input. It checks for possible zero entries in the vector. This routine returns a boolean assigned to \lstinline[style=CStyle]|SUNTRUE| if all
 	components of the vector are nonzero (successful inversion) and returns \lstinline[style=CStyle]|SUNFALSE| otherwise.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|booleantype N_VInvTest_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VConstrMask\_PSBLAS}}] Performs the following constraint tests: $x_i > 0$ if $c_i = 2$, $x_i \geq 0$ if $c_i = 1$,
 	$x_i \leq 0$ if $c_i = -1$, $x_i < 0$ if $c_i = -2$. There is no constraint on $x_i$ if $c_i = 0$.
 	This routine returns a boolean assigned to \lstinline[style=CStyle]|SUNFALSE| if any element failed
 	the constraint test and assigned to \lstinline[style=CStyle]|SUNTRUE| if all passed. It also sets a
 	mask vector \lstinline[style=CStyle]|m|, with elements equal to \lstinline[style=CStyle]|1.0| where the constraint test failed,
 	and \lstinline[style=CStyle]|0.0| where the test passed. This routine is used only for constraint
 	checking.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|booleantype N_VConstrMask_PSBLAS(N_Vector c, N_Vector x, N_Vector m)|
 	
 	\item[\fbox{\texttt{N\_VMinQuotient\_PSBLAS}}] This routine returns the minimum of the quotients obtained by term-wise
 	dividing \lstinline[style=CStyle]|num[i]| by \lstinline[style=CStyle]|denom[i]| . A zero element in \lstinline[style=CStyle]|denom| will be skipped. If no
 	such quotients are found, then the large value \lstinline[style=CStyle]|BIG REAL| (defined in the
 	header file sundials \texttt{types.h}) is returned.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMinQuotient_PSBLAS(N_Vector num, N_Vector denom)|
 	
\end{description}

\subsubsection{Fused operation}
\begin{description}
 	\item[\fbox{\texttt{N\_VLinearCombination\_PSBLAS}}] This routine computes the linear combination of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements
 	\begin{equation*}
 		z_i = \sum_{j=0}^{n_v - 1} c_j x_{j,i}, \qquad i=0,\ldots,n-1
 	\end{equation*}
 	where \lstinline[style=CStyle]|c| is an array of \lstinline[style=CStyle]|nv| scalars, \lstinline[style=CStyle]|X| is an array of NVECTOR\_PSBLAS. When \lstinline[style=CStyle]|z| is one of the vectors in \lstinline[style=CStyle]|X|, then it is assumed to be the first vector in the vector array.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearCombination_PSBLAS(int nvec, realtype* c, N_Vector* V,N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VScaleAddMulti\_PSBLAS}}] This routine scales and adds one vector to \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements:
 	\begin{equation*}
 		z_{j,i} = c_j x_i + y_{j,i}, \qquad j=0,\ldots,n_v-1, \qquad i=0,\ldots,n-1,
 	\end{equation*}
 	where \lstinline[style=CStyle]|c| is an array of \lstinline[style=CStyle]|nv| scalars.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleAddMulti_PSBLAS(int nvec, realtype* a, N_Vector x, N_Vector* Y, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VDotProdMulti\_PSBLAS}}] This routine computes the dot product of a vector with \lstinline[style=CStyle]|nv| other vectors.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VDotProdMulti_PSBLAS(int nvec, N_Vector x,N_Vector *Y, realtype* dotprods)|
 \end{description}
	\subsubsection{Vector array operations}
 \begin{description}
 	\item[\fbox{\texttt{N\_VLinearSumVectorArray\_PSBLAS}}] This routine computes the linear sum of two vector arrays
 	containing \lstinline[style=CStyle]|nv| vectors of \lstinline[style=CStyle]|n| elements:
 	\begin{equation*}
 		z_{j,i} = a x_{j,i} + b y_{j,i}, \qquad i=0,\ldots,n-1, \qquad j=0,\ldots,n_v -1.
 	\end{equation*}
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearSumVectorArray_PSBLAS(int nvec, realtype a, N_Vector* X, realtype b, N_Vector* Y, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VScaleVectorArray\_PSBLAS}}] This routine scales each vector of \lstinline[style=CStyle]|n| elements in a vector
 	array of \lstinline[style=CStyle]|n_v| vectors by a (potentially different) constant:
 	\begin{equation*}
 		z_{j,i} = c_j x_{j,i}, \qquad i=0,\ldots,n-1, \qquad j=0,\ldots,n_v-1.
 	\end{equation*}
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleVectorArray_PSBLAS(int nvec, realtype* c,N_Vector* X, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VConstVectorArray\_PSBLAS}}] This routine sets each element in a vector of \lstinline[style=CStyle]|n|  elements in a vector array of \lstinline[style=CStyle]|nv|  vectors to the same value.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VConstVectorArray_PSBLAS(int nvecs, realtype c,N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormVectorArray\_PSBLAS}}] This routine computes the weighted root mean square
 	norm of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VWrmsNormVectorArray_PSBLAS(int nvecs, N_Vector* X,N_Vector* W, realtype* nrm)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormMaskVectorArray\_PSBLAS}}] This routine computes the masked weighted root mean square norm of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VWrmsNormMaskVectorArray_PSBLAS(int nvec, N_Vector* X,N_Vector* W, N_Vector id,realtype* nrm)|
 	
 	\item[\fbox{\texttt{N\_VScaleAddMultiVectorArray\_PSBLAS}}] This routine scales and adds a vector in a vector array of
 	\lstinline[style=CStyle]|nv| vectors to the corresponding vector in \lstinline[style=CStyle]|ns| vector arrays.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleAddMultiVectorArray_PSBLAS(int nvec, int nsum, realtype* a, N_Vector* X, N_Vector** Y, N_Vector** Z)|
 	
 	\item[\fbox{\texttt{N\_VLinearCombinationVectorArray\_PSBLAS}}] This routine computes the linear combination of \lstinline[style=CStyle]|ns| vector
 	arrays containing \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearCombinationVectorArray_PSBLAS(int nvec, int nsum, realtype* c, N_Vector** X, N_Vector* Z)|
\end{description}

By default all fused and vector array operations are disabled in the nvector PSBLAS module.
The following additional user-callable routines are provided to enable or disable fused and vector
array operations for a specific vector.
\begin{lstlisting}[style=CStyle]
int N_VEnableFusedOps_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearCombination_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleAddMulti_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableDotProdMulti_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearSumVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableConstVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableWrmsNormVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableWrmsNormMaskVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleAddMultiVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearCombinationVectorArray_PSBLAS(N_Vector v,booleantype tf);
\end{lstlisting}

\section{The SUNMATRIX\_PSBLAS implementation}\label{sec:sunmatrix}

\marginlabel{
\textit{Library structure}
\begin{minipage}{0.9\textwidth}
\dirtree{%
 .1 kinsol-psblas.
 .2 config.
 .2 doc.
 .2 examples.
 .3 sunmatrix.
 .4 psblas.
 .2 include.
 .3 sunmatrix.
 .2 src.
 .3 sunmatrix.
 .4 psblas.
 .2 test.
}
\end{minipage}}The SUNMATRIX\_PSBLAS implementation of the SUNDIALS SUNMATRIX module provides an interface to the PSBLAS code for handling distributed sparse matrices.
It defines the \emph{content} field of \texttt{SUNMATRIX} to be a structure containing the PSBLAS descriptor for the data distribution, a PSBLAS sparse matrix object of double, and the PSBLAS communicator (context).

\begin{lstlisting}[style=CStyle]
struct _SUNMatrixContent_PSBLAS {
 psb_c_descriptor *cdh;/* descriptor for data distribution */
 psb_c_dspmat  *ah;    /* PSBLAS sparse matrix             */
 int ictxt;            /* PSBLAS communicator              */
};
\end{lstlisting}

\attention All the matrices that have to interact needs to be instantiated on the same parallel context \lstinline[style=CStyle]|ictxt|, and on the same data distribution \lstinline[style=CStyle]|cdh|, and this holds also for the vectors for the mixed type operation.


The header file to include when using this module is \texttt{sunmatrix\_psblas.h}. The installed module library to link to is \texttt{libsundials\_sunmatrixpsblas.a} where \texttt{.lib} is typically \texttt{.so} for shared libraries and \texttt{.a} for static libraries.

\subsection{SUNMATRIX\_PSBLAS accessor macros}

The following macros are provided to access the content of a SUNMATRIX\_PSBLAS matrix. The suffix \texttt{\_P} in the names denotes the fact that the data are in distributed memory.

\begin{lstlisting}[style=CStyle]
#define SM_CONTENT_P(A)     ( (SUNMatrixContent_PSBLAS)(A->content) )
#define SM_DESCRIPTOR_P(A)  ( SM_CONTENT_P(A)->cdh )
#define SM_PMAT_P(A)        ( SM_CONTENT_P(A)->ah )
#define SM_ICTXT_P(A)       ( SM_CONTENT_P(A)->ictxt )
\end{lstlisting}

\marginlabel{\lstinline[style=CStyle]|SM_CONTENT_P(A)|} this macro gives access to the contents of the PSBLAS matrix \texttt{SUNMATRIX}.

\marginlabel{\lstinline[style=CStyle]|SM_DESCRIPTOR_P(A),SM_PMAT_P(A)|} these macros give instead individual access to the parts of the content of a PSBLAS parallel \texttt{SUNMATRIX}.

\marginlabel{\lstinline[style=CStyle]|SM_CONTENT_P(A)|} this macro provides the PSBLAS context used by the SUNMATRIX\_PSBLAS sparse matrices.

In PSBLAS every sparse matrix has an associated state, which can take one of the following
values:
\begin{description}
\item[BUILD] is the state entered after the first allocation, and before the first assembly; in
this state it is possible to add nonzero entries.
\item[ASSEMBLED] is the state entered after the assembly; computations using the sparse
matrix, such as matrix-vector products, are only possible in this state;
\item[UPDATE] state entered after a reinitalization; this is used to handle applications
in which the same sparsity pattern is used multiple times with different
coefficients. \attention In this state \textit{it is only possible to enter coefficients for already
existing nonzero entries}.
\end{description}

\subsection{SUNMATRIX\_PSBLAS functions}

The SUNMATRIX\_PSBLAS implementation provides PSBLAS implementations of all the sparse matrix operations listed in Table~7.2 of the original KINSOL library~\cite{kinsolguide}. Following the standard nomenclature of the SUNDIALS library, their names are obtained from the ones listed in Table~7.2 by appending the suffix \texttt{\_PSBLAS}. The SUNMATRIX\_PSBLAS implementation provides the following additional user--callable routines

\begin{description}
	\item[\fbox{\texttt{SUNMatAsb\_PSBLAS}}] This routine assemble the SUNMATRIX after that all the elements have been inserted into it, i.e., after that all the calls to the \texttt{SUNMatIns\_PSBLAS} routine have been completed. This is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dspasb|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatAsb_PSBLAS(SUNMatrix A);|
	
	\item[\fbox{\texttt{SUNMatIns\_PSBLAS}}] This routine inserts a set of coefficients into a sparse matrix. On entry to this routine the descriptor may be in either the BUILD or ASSEMBLED state, while the sparse matrix may be in either the BUILD or UPDATE state. We stress that it mandatory that if the descriptor is in the BUILD state, then also the sparse matrix \textit{must} be in
	the BUILD state, since adding entries to the matrix causes internal calls altering the structure of the communication pattern for the distributed object. The insert of the element in the matrix si assumed to be in the COO format, thus the coefficients to be inserted are represented by the ordered triples \lstinline[style=CStyle]|irw[i]|, \lstinline[style=CStyle]|icl[i]|, \lstinline[style=CStyle]|val[i]|, for $i = 1,\ldots,\lstinline[style=CStyle]|nz|$; these triples should belong to the current process, i.e., the index \lstinline[style=CStyle]|irw[i]| should be one of the local indices, but are otherwise arbitrary, it this is not the case any coefficients from matrix rows not owned by the calling process are
	silently ignored.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatIns_PSBLAS(psb_i_t nz, const psb_l_t *irw, const psb_l_t *icl, const psb_d_t *val,SUNMatrix A);|
\end{description}

\subsubsection{Description of the SUNMATRIX\_PSBLAS functions}

\begin{description}
\item[\fbox{\texttt{SUNPSBLASMatrix}}] Define and implement user-callable constructor routines to create a
SUNMatrix on the PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh|, and with the content field and ops pointing to the matrix operations defined in the following. The matrix is initialized in the BUILD state.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNMatrix SUNPSBLASMatrix(int ictxt, psb_c_descriptor *cdh)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_Print}}] This function prints the content of a dense SUNMatrix in MatrixMarket format to file specified by \texttt{filename}, the routine takes care of creating/opening the file, a separated one for each process in which the local part (without any eventual overlap) is printed.

\marginlabel{Prototype} \lstinline[style=CStyle]|void SUNPSBLASMatrix_Print(SUNMatrix A,char *matrixtitle,char *filename)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_Rows}}] This function returns the number of (global) rows in the PSBLAS SUNMatrix.

\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype SUNPSBLASMatrix_Rows(SUNMatrix A)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_Columns}}] This function returns the number of (global) columns in the PSBLAS SUNMatrix.

\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype SUNPSBLASMatrix_Columns(SUNMatrix A)|

\item[\fbox{\texttt{SUNPSBLASMatrix\_NNZ}}] This function returns the (global) number of non-zero entries in the PSBLAS SUNMatrix.

\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype SUNPSBLASMatrix_NNZ(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatGetID\_PSBLAS}}] Returns the type identifier for the matrix \texttt{A}, since this is a custom implementation it returns the value \texttt{SUNMATRIX\_CUSTOM}.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNMatrix_ID SUNMatGetID_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatClone\_PSBLAS}}] Creates a new SUNMatrix on the same descriptor of an existing matrix \texttt{A} and sets
the \texttt{ops} field. It \textbf{does not copy} the matrix, but rather allocates storage for the new matrix leaving the new matrix in the BUILD state.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNMatrix SUNMatClone_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatDestroy\_PSBLAS}}] Destroys the SUNMatrix \texttt{A} and frees memory allocated for its internal data. This routine \textbf{does not free} the communicator, in general there are many objects insisting on the same communicator, therefore it should be destroyed/freed on its own.

\marginlabel{Prototype} \lstinline[style=CStyle]|void SUNMatDestroy_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatZero\_PSBLAS}}] Performs the operation $(A)_{i,j} = 0$ for all entries of the matrix \texttt{A}. The return value is an integer flag denoting success/failure of the operation. The PSBLAS at the end of this operation is left in the UPDATE state.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatZero_PSBLAS(SUNMatrix A)|

\item[\fbox{\texttt{SUNMatCopy\_PSBLAS}}] Performs the operation $(B)_{i,j} = (A)_{ i,j}$ for all entries of the matrices \texttt{A} and \texttt{B}. The return value is an integer flag denoting success/failure of the operation. The matrix \texttt{B} inherits the state of the matrix \texttt{A}.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatCopy_PSBLAS(SUNMatrix A, SUNMatrix B)|

\item[\fbox{\texttt{SUNMatScaleAdd\_PSBLAS}}] Performs the operation $A = cA + B$. The return value is an integer flag denoting success/failure of the operation. This function assumes that both the matrices are defined on the same communicator.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatScaleAdd_PSBLAS(realtype c, SUNMatrix A, SUNMatrix B)|

\item[\fbox{\texttt{SUNMatScaleAddI\_PSBLAS}}] Performs the operation $A = cA + I$. The return value is an integer flag denoting success/failure of the operation.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatScaleAddI_PSBLAS(realtype c, SUNMatrix A)|

\item[\fbox{\texttt{SUNMatMatvec\_PSBLAS}}] Performs the matrix-vector product operation, $\mathbf{y} = A\mathbf{x}$. It should only be
called with vectors $\mathbf{x}$ and $\mathbf{y}$ that are compatible with the matrix $A$, i.e., they should be both defined on the same communicator and have the same dimensions. The return value is an integer flag denoting
success/failure of the operation.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatMatvec_PSBLAS(SUNMatrix A, N_Vector x, N_Vector y)|

\item[\fbox{\texttt{SUNMatSpace\_PSBLAS}}] This function is advisory only, for use in determining a user's total space requirements, for this module it is a dummy function always returning true.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNMatSpace_PSBLAS(SUNMatrix A, long int *lenrw, long int *leniw)|
\end{description}

\subsubsection{An example of matrix assembly}\label{sec:example_of_matrix_assembly}

As an example of usage of this matrix routines we consider the same boundary value problem in~\eqref{eq:boundaryproblem}, to build the matrix $A$ associated to a second-order centered finite difference discretization scheme.
To this end we use the same communicator \texttt{cdh} and context \texttt{ictxt} we have allocated in Listing~\ref{lst:example_of_allocation}, by simply doing:
\begin{lstlisting}[style=CStyle]
A = SUNPSBLASMatrix(ictxt, cdh);
matgen(ictxt, nl, idim, vl,A);
psb_c_cdasb(cdh);
SUNMatAsb_PSBLAS(A);
\end{lstlisting}
We have first initialized the sparse PSBLAS matrix inside the SUNMATRIX container, then by using the \texttt{matgen} allocation routine in Listing~\ref{lst:allocationroutine} we have populated the sparse matrix, and finally assembled both the descriptor and the sparse matrix.

The complete example can be found in \texttt{examples/sunmatrix/psblas}.

\section{The SUNLINSOL\_PSBLAS implementation}\label{sec:sunlinsol}
\marginlabel{
\textit{Library structure}
\begin{minipage}{0.9\textwidth}
\dirtree{%
 .1 kinsol-psblas.
 .2 config.
 .2 doc.
 .2 examples.
 .3 sunlinsol.
 .4 psblas.
 .2 include.
 .3 sunlinsol.
 .2 src.
 .3 sunlinsol.
 .4 psblas.
 .2 test.
}
\end{minipage}
}	The SUNLINSOL\_PSBLAS implementation of the SUNDIALS SUNLINSOL module provides an interface to the PSBLAS code for handling the iterative solution of large and sparse linear systems. It defines the \emph{content} field of \texttt{SUNLinsol} to be a structure containing the options needed to setup a PSBLAS solver, the PSBLAS descriptor for the data distribution, the pointer to both PSBLAS and MLD2P4 preconditioner, the PSBLAS sparse matrix for which the solver (and the preconditioner) is instantiated, the PSBLAS communicator (context), and two strings that identify what iterative method and type of preconditioner we are dealing with.
\begin{lstlisting}[style=CStyle]
struct _SUNLinearSolverContent_PSBLAS {
 psb_c_SolverOptions options;/* PSBLAS solver options    */
 psb_c_dprec *ph;            /* PSBLAS preconditioner    */
 mld_c_dprec *mh;            /* MLD2P4 preconditioner    */
 psb_c_descriptor *cdh;      /* Descriptor               */
 psb_c_dspmat  *ah;          /* PSBLAS sparse matrix     */
 int ictxt;                  /* PSBLAS communicator      */
 char methd[40];             /* String for Method        */
 char ptype[20];             /* String for Preconditioner*/
};
\end{lstlisting}

The structure \texttt{options} contains the options that are common in between the different iterative solver included in PSBLAS that are interfaced with this library
\begin{lstlisting}[style=CStyle]
typedef struct psb_c_solveroptions {
 int iter;  /* On exit how many iterations were performed */
 int itmax; /* On entry maximum number of iterations      */
 int itrace;/* On entry print an info message every itrace iterations */
 int irst;  /* Restart depth for RGMRES or BiCGSTAB(L)    */
 int istop; /* Stopping criterion: 1:backward error 2: ||r||_2/||b||_2 */
 double eps;/* Stopping tolerance */
 double err;/* Convergence indicator on exit */
} psb_c_SolverOptions;
\end{lstlisting}
The default settings for this structure can be set by means of the \lstinline[style=CStyle]|psb_c_DefaultSolverOptions| routine

\marginlabel{Prototype} \lstinline[style=CStyle]| int psb_c_DefaultSolverOptions(psb_c_SolverOptions *options)|
that sets the following default values
\begin{lstlisting}[style=CStyle]
options.itmax  = 1000;
options.itrace = 0;
options.istop  = 2;
options.irst   = 10;
options.eps    = 1.d-6;
err            = 0;
\end{lstlisting}

Specifically, the Krylov method included from the PSBLAS library are given in Table~\ref{tab:krylov_methods}, and that permit to solve a wide range of problems.
\begin{fulltable}[htbp]
\centering
\begin{tabular}{lll}
\toprule
\lstinline[style=CStyle]|methd| & Method & Type of Matrix \\
\midrule
\lstinline[style=CStyle]|"CG"| & Conjugate Gradient & SPD \\
\lstinline[style=CStyle]|"CGS"| & Conjugate Gradient Stabilized  & General \\
\lstinline[style=CStyle]|"GCR"| & Generalized Conjugate Residual  & SPD  \\
\lstinline[style=CStyle]|"FCG"| & Flexible Conjugate Gradient  & SPD  \\
\lstinline[style=CStyle]|"BICG"| & Bi-Conjugate Gradient & General \\
\lstinline[style=CStyle]|"BICGSTAB"| & Bi-Conjugate Gradient Stabilized & General \\
\lstinline[style=CStyle]|"BICGSTABL"| & Restarted Bi-Conjugate Gradient Stabilized& General \\
\lstinline[style=CStyle]|"RGMRES"| & Restarted Generalized Minimal Residual & General \\
\bottomrule
\end{tabular}
	\caption{Krylov methods included with the PSBLAS library.}\label{tab:krylov_methods}
\end{fulltable}

	The general type of preconditioner can be instead selected by means of the string \lstinline[style=CStyle]|ptype|, that can assume three values for the basic preconditioner implemented in the core PSBLAS library that are
	\begin{description}
		\item[\textcolor{mPurple}{\texttt{"NONE"}}] no preconditioning is used, i.e., the preconditioner is just a copy operator acting on the residuals,
		\item[\textcolor{mPurple}{\texttt{"BJAC"}}] precondition by means of a factorization of the block-diagonal of matrix A, the block boundaries are determined by using the data allocation boundaries that have been defined for each process. It is implemented to require no communication, to solve the system on the blocks a version of incomplete ILU(0) factorization is used.
		\item[\textcolor{mPurple}{\texttt{"DIAG"}}] this is a simple diagonal scaling; each entry of the input vector is multiplied by the reciprocal of the sum of the absolute values of the coefficients in the corresponding row of matrix A.
	\end{description}
	Each of this choices select the routines that work with the \lstinline[style=CStyle]|psb_c_dprec *ph| in the SUNLINSOL content and leaves \lstinline[style=CStyle]|mld_c_dprec *mh| a \lstinline[style=CStyle]|NULL| pointer.

	The more elaborated \textit{multilevel} preconditioners are enable by setting \lstinline[style=CStyle]|ptype| to one of the following string
	\begin{description}
%		\item[\textcolor{mPurple}{\texttt{"GS"}}] hybrid Gauss-Seidel (forward), that is, a global block Jacobi preconditioner with Gauss-Seidel as local solver on the blocks,
%		\item[\textcolor{mPurple}{\texttt{"FBGS"}}] symmetrized hybrid Gauss-Seidel,that is, forward Gauss-Seidel followed by backward Gauss-Seidel.
		\item[\textcolor{mPurple}{\texttt{"AS"}}] Additive Schwarz (AS) this enables the construction of a one-level domain decomposition preconditioner, based on Additive Schwarz methods for which all the details are described in the ML2DP4 user's and reference guide~\cite{mld2p4guide}.
% with overlap 1 and ILU(0) on the local blocks.
		\item[\textcolor{mPurple}{\texttt{"ML"}}] this enables the construction of a multilevel preconditioner for which details are described in Section~\ref{sec:mld2p4}, and are based on the ML2DP4 package~\cite{MR2738234,mld2p4guide}.
	\end{description}
	This choice selects the routines that work with the \lstinline[style=CStyle]|mld_c_dprec *mh| in the SUNLINSOL content and leaves \lstinline[style=CStyle]|psb_c_dprec *ph| a \lstinline[style=CStyle]|NULL| pointer.


\subsection{SUNLINSOL\_PSBLAS accessor macros}

The following macros are provided to access the content of a SUNLINSOL\_PSBLAS linear solver. The suffix \texttt{\_P} in the names denotes the fact that the data are in distributed memory.

\begin{lstlisting}[style=CStyle]
#define PSBLAS_CONTENT(S)  ( (SUNLinearSolverContent_PSBLAS)(S->content) )
#define LS_PREC_P(S)       ( PSBLAS_CONTENT(S)->ph )
#define LS_MLPREC_P(S)     ( PSBLAS_CONTENT(S)->mh )
#define LS_DESCRIPTOR_P(S) ( PSBLAS_CONTENT(S)->cdh )
#define LS_PMAT_P(S)       ( PSBLAS_CONTENT(S)->ah )
#define LS_ICTXT_P(S)      ( PSBLAS_CONTENT(S)->ictxt )
#define LS_METHD_P(S)      ( PSBLAS_CONTENT(S)->methd )
#define LS_PTYPE_P(S)      ( PSBLAS_CONTENT(S)->ptype )
\end{lstlisting}

\marginlabel{\texttt{PSBLAS\_CONTENT(S)}} this macro gives access to the contents of the PSBLAS linear solver \texttt{SUNLINSOL}.
	
\marginlabel{\texttt{LS\_PREC\_P(S)}} this macro gives access to the pointer to the PSBLAS preconditioner object.

\marginlabel{\texttt{LS\_MLPREC\_P(S)}} this macro gives access to the pointer to the MLD2P4 preconditioner object.

\marginlabel{\texttt{LS\_DESCRIPTOR\_P(S)}, \texttt{LS\_PMAT\_P(S)}} these macros give instead individual access to the parts of the content of a PSBLAS parallel \texttt{SUNMATRIX}.

\marginlabel{\texttt{LS\_ICTXT\_P(S)}} this macro provides the PSBLAS context used by the SUNMATRIX\_PSBLAS sparse matrices and vectors.

\marginlabel{\texttt{LS\_METHD\_P(S)}} this macro gives access to the string that select the type of Krylov solver to be used as iterative method.

\marginlabel{\texttt{LS\_PTYPE\_P(S)}} this macro gives access to the string that select the type of preconditioner to be used within the iterative method.

\subsection{SUNLINSOL\_PSBLAS functions}

The SUNLINSOL\_PSBLAS implementation provides PSBLAS implementations of all the linear solver operations listed in KINSOL library~\cite[Section~8.1.1]{kinsolguide}. Following the standard nomenclature of the SUNDIALS library, their names are obtained from the ones listed there by appending the suffix \texttt{\_PSBLAS}. The SUNLINSOL\_PSBLAS implementation provides the following additional user--callable routines that can be used to set-up the values for the \lstinline[style=CStyle]|ptype="ML"| preconditioners.

\begin{description}
\item[\fbox{\texttt{SUNLinSolSeti\_PSBLAS}}] given a linear solver with \lstinline[style=CStyle]|ptype="ML"| this routine set the option \lstinline[style=CStyle]|const char *what| to the given integer value

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolSeti_PSBLAS(SUNLinearSolver S, const char *what, psb_i_t val)|

\item[\fbox{\texttt{SUNLinSolSetc\_PSBLAS}}] given a linear solver with \lstinline[style=CStyle]|ptype="ML"| this routine set the option \lstinline[style=CStyle]|const char *what| to the given string value

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolSetc_PSBLAS(SUNLinearSolver S, const char *what, const char *val)|

\item[\fbox{\texttt{SUNLinSolSetr\_PSBLAS}}] given a linear solver with \lstinline[style=CStyle]|ptype="ML"| this routine set the option \lstinline[style=CStyle]|const char *what| to the given \lstinline[style=CStyle]|double val|

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolSetr_PSBLAS(SUNLinearSolver S, const char *what, double val)|
\end{description}

The detail of the options for the various solver are recalled in Section~\ref{sec:mld2p4}, and are fully detailed in~\cite{mld2p4guide}.

\subsubsection{Description of the SUNLINSOL\_PSBLAS functions}

\begin{description}

\item[\fbox{\texttt{SUNLinSol\_PSBLAS}}] Only the solver options are set at this stage, all the information regarding the communicator, the PSBLAS contex are imported from the matrix when the solver is initialized. The setup of the preconditioner has to be done with the \lstinline[style=CStyle]|SUNLinSolSetup_PSBLAS| routine. Here the codes decide only if we are using a PSBLAS or an MLD2P4 preconditioner by looking at the string char \lstinline[style=CStyle]|ptype[]|.
	
\marginlabel{Prototype} \lstinline[style=CStyle]|SUNLinearSolver SUNLinSol_PSBLAS(psb_c_SolverOptions options, char methd[], char ptype[])|

\item[\fbox{\texttt{SUNLinSolGetType\_PSBLAS}}] this function returns the type identifier for the linear solver, that in this case is of matrix-iterative type.

\marginlabel{Prototype} \lstinline[style=CStyle]|SUNLinearSolver_Type SUNLinSolGetType_PSBLAS(SUNLinearSolver S)|

\item[\fbox{\texttt{SUNLinSolInitialize\_PSBLAS}}] this function performs the linear solver initialization by assuming that all solver-specific options have been set, i.e., in the case of \lstinline[style=CStyle]|ptype="ML"| preconditioner after the calls to the \texttt{SUNLinSolSet[i,c,r]\_PSBLAS} routines.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolInitialize_PSBLAS(SUNLinearSolver S)|

\item[\fbox{\texttt{SUNLinSolSetup\_PSBLAS}}] this function performs the linear solver setup, based on an (possibly) updated system \lstinline[style=CStyle]|SUNMATRIX A|. This may be called frequently (e.g., with a full
Newton method) or infrequently (for a modified Newton method), based on the type of
integrator and/or nonlinear solver requesting the solves.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolSetup_PSBLAS(SUNLinearSolver S, SUNMatrix A)|

\item[\fbox{\texttt{SUNLinSolSolve\_PSBLAS}}] this function performs the actual solve of the linear system $A\mathbf{x} = \mathbf{b}$ (by eventually using the preconditioner $P^{-1}$ encoded in the \lstinline[style=CStyle]|SUNLinearSolver S|).

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolSolve_PSBLAS(SUNLinearSolver S, SUNMatrix A,N_Vector x, N_Vector b,realtype tol)|

\item[\fbox{\texttt{SUNLinSolFree\_PSBLAS}}] this function frees memory allocated by the linear solver, it is important to notice that this routine frees only the preconditioner and the structure containing the various part of the solver: the communicator and the matrix are still there, they should be freed after the matrix has been destroyed.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolFree_PSBLAS(SUNLinearSolver S)|

\item[\fbox{\texttt{SUNLinSolNumIters\_PSBLAS}}] return the number of linear iterations
performed in the last solve call.

\marginlabel{Prototype} \lstinline[style=CStyle]|int SUNLinSolNumIters_PSBLAS(SUNLinearSolver S)|

\item[\fbox{\texttt{SUNLinSolResNorm\_PSBLAS}}] return the residual of the last linear iteration performed in the last solve call.

\marginlabel{Prototype} \lstinline[style=CStyle]|realtype SUNLinSolResNorm_PSBLAS(SUNLinearSolver S)|

\item[\fbox{\texttt{SUNLinSolLastFlag\_PSBLAS}}] return the last error flag encountered
within the linear solver. This is not called by the sundials packages directly; it allows
the user to investigate linear solver issues after a failed solve.

\marginlabel{Prototype} \lstinline[style=CStyle]|long int SUNLinSolLastFlag_PSBLAS(SUNLinearSolver S)|
\end{description}

\subsection{Algebraic Multigrid Preconditioners: the MLD2P4 package}\label{sec:mld2p4}

We consider here the classic set of an algebraic multigrid preconditioner. Thus we have as finest index space the set of row (column) indices of $A$, i.e.,
$\Omega = \{1, 2, \ldots, n\}$.
Any of the algebraic multilevel preconditioners that is implemented in the MLD2P4 package generates a hierarchy of index spaces and a corresponding hierarchy of matrices,
\[ \Omega^1 \equiv \Omega \supset \Omega^2 \supset \ldots \supset \Omega^{nlev},
\quad A^1 \equiv A, A^2, \ldots, A^{nlev}, \]
by using the information contained in $A$, \textbf{without assuming any
knowledge of the geometry of the problem} from which $A$ originates.
A vector space $\mathbb{R}^{n_{k}}$ is associated with $\Omega^k$,
where $n_k$ is the size of $\Omega^k$.
For all $k < nlev$, a restriction operator and a prolongation one are built,
which connect two levels $k$ and $k+1$:
\[
P^k \in \mathbb{R}^{n_k \times n_{k+1}}, \quad
R^k \in \mathbb{R}^{n_{k+1}\times n_k};
\]
the matrix $A^{k+1}$ is computed by using the previous operators according
to the Galerkin approach, i.e.,
\[
A^{k+1}=R^kA^kP^k.
\]
For the construction of $R^k$ we have that $R^k=(P^k)^T$.
A smoother with iteration matrix $M^k$ is set up at each level $k < nlev$, and a solver
is set up at the coarsest level, so that they are ready for application.

All this construction is what is usually called the setup phase of the hierarchy of AMG components, i.e., the so-called build phase of the preconditioner.

The MLD2P4 package offers a plethora of way to obtain all the ingredient needed to build what is described here. These are explained in Tables~2 to~8 in~\cite{mld2p4guide} and, depending on the type of option, can all be set by means of the \lstinline[style=CStyle]|SUNLinSolSet[i/c/r]_PSBLAS| routines.

We refer back to the guide~\cite{mld2p4guide} for the full details on how to setup the preconditioner.

\subsubsection{An example of linear system solution}

We can consider the same context of Example~\ref{ex:the_example}, with the matrix construction detail in Section~\ref{sec:example_of_matrix_assembly}. Now that both the data distribution, and the construction of the (distributed) sparse matrix $A$ and right hand-side $\mathbf{b}$ have been completed we only need to create the SUNLINSOL object, and setup the preconditioner.

\begin{lstlisting}[style=CStyle,caption="An example of solution with PCG preconditioned by a ML preconditioner",label=lst:thesolution]
SUNLinearSolver LS;             /* linear solver object    */
psb_c_SolverOptions options;    /* Solver options          */
/* Set up the solver options */
psb_c_DefaultSolverOptions(&options);
options.eps    = tol;
options.itmax  = itmax;
options.irst   = irst;
options.itrace = 1;
options.istop  = istop;
/* Create PSBLAS/MLD2P4 linear solver */
LS = SUNLinSol_PSBLAS(options, "CG", "ML");
SUNLinSolInitialize(LS);
SUNLinSolSeti_PSBLAS(LS,"SMOOTHER_SWEEPS",2);
SUNLinSolSeti_PSBLAS(LS,"SUB_FILLIN",1);
SUNLinSolSetc_PSBLAS(LS,"COARSE_SOLVE","BJAC");
SUNLinSolSetc_PSBLAS(LS,"COARSE_SUBSOLVE","ILU");
SUNLinSolSeti_PSBLAS(LS,"COARSE_FILLIN",0);
SUNLinSolSetup(LS, A);
SUNLinSolSolve_PSBLAS(LS, A, x, b, tol);
\end{lstlisting}

The example given in the code~\ref{lst:thesolution}, initializes a linear solver requesting for a Conjugate Gradient method (\lstinline[style=CStyle]|"CG"|), preconditioned by a multi-level preconditioner (\lstinline[style=CStyle]|"ML"|). Then, after the initialization step, some of the properties of the multigrid cycle are selected. Specifically, we decide to use two smoother sweeps of Block-Jacobi with an ILU(1) subsolver (\lstinline[style=CStyle]|"SUB_FILLIN"|), and set again a Block-Jacobi method as coarse solver (\lstinline[style=CStyle]|"COARSE_SUBSOLVE"|) that uses instead as solver for the blocks and ILU(0) (\lstinline[style=CStyle]|"COARSE_FILLIN"|) factorization. Then a setup step is performed, during this step the multigrid hierarchy is assembled. Finally the solution of the linear system is computed by a call to \lstinline[style=CStyle]|SUNLinSolSolve_PSBLAS|. Observe that if we have put the value \lstinline[style=CStyle]|options.itrace = 1;| the solve routine will print convergence information for each iteration.

\appendix

\section{Matrix assembly routine}
The following routine loops through the local entries of the communicator allocate in Listing~\ref{lst:example_of_allocation}, and uses the \texttt{SUNMatIns\_PSBLAS} routine to insert the entries in the sparse matrix. The auxiliary functions $\{a_{i},b_i,g\}_{i=1}^3$ take care of the coefficient functions in~\eqref{eq:boundaryproblem}.
\begin{lstlisting}[style=CStyle,caption="Allocation routine for the discrete boundary value problem~\eqref{eq:boundaryproblem}.",label=lst:allocationroutine]
psb_i_t matgen(psb_i_t ictxt, psb_i_t nl, psb_i_t idim, psb_l_t vl[],SUNMatrix A)
{
psb_i_t iam, np;
psb_l_t ix, iy, iz, el,glob_row;
psb_i_t i, k, info;
double x, y, z, deltah, sqdeltah, deltah2;
double val[10*NBMAX], zt[NBMAX];
psb_l_t irow[10*NBMAX], icol[10*NBMAX];

info = 0;
psb_c_info(ictxt,&iam,&np);
deltah = (double) 1.0/(idim+1);
sqdeltah = deltah*deltah;
deltah2  = 2.0* deltah;
psb_c_set_index_base(0);
for (i=0; i<nl;  i++) {
glob_row=vl[i];
el=0;
ix = glob_row/(idim*idim);
iy = (glob_row-ix*idim*idim)/idim;
iz = glob_row-ix*idim*idim-iy*idim;
x=(ix+1)*deltah;
y=(iy+1)*deltah;
z=(iz+1)*deltah;
zt[0] = 0.0;
/*  internal point: build discretization */
/*  term depending on   (x-1,y,z)        */
val[el] = -a1(x,y,z)/sqdeltah-b1(x,y,z)/deltah2;
if (ix==0) {
zt[0] += g(0.0,y,z)*(-val[el]);
} else {
icol[el]=(ix-1)*idim*idim+(iy)*idim+(iz);
el=el+1;
}
/*  term depending on     (x,y-1,z) */
val[el]  = -a2(x,y,z)/sqdeltah-b2(x,y,z)/deltah2;
if (iy==0) {
zt[0] += g(x,0.0,z)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy-1)*idim+(iz);
el=el+1;
}
/* term depending on     (x,y,z-1)*/
val[el]=-a3(x,y,z)/sqdeltah-b3(x,y,z)/deltah2;
if (iz==0) {
zt[0] += g(x,y,0.0)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy)*idim+(iz-1);
el=el+1;
}
/* term depending on     (x,y,z)*/
val[el]=2.0*(a1(x,y,z)+a2(x,y,z)+a3(x,y,z))/sqdeltah + c(x,y,z);
icol[el]=(ix)*idim*idim+(iy)*idim+(iz);
el=el+1;
/*  term depending on     (x,y,z+1) */
val[el] = -a3(x,y,z)/sqdeltah+b3(x,y,z)/deltah2;
if (iz==idim-1) {
zt[0] += g(x,y,1.0)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy)*idim+(iz+1);
el=el+1;
}
/* term depending on     (x,y+1,z) */
val[el] = -a2(x,y,z)/sqdeltah+b2(x,y,z)/deltah2;
if (iy==idim-1) {
zt[0] += g(x,1.0,z)*(-val[el]);
} else {
icol[el]=(ix)*idim*idim+(iy+1)*idim+(iz);
el=el+1;
}
/*  term depending on     (x+1,y,z) */
val[el] = -a1(x,y,z)/sqdeltah+b1(x,y,z)/deltah2;
if (ix==idim-1) {
zt[0] += g(1.0,y,z)*(-val[el]);
} else {
icol[el]=(ix+1)*idim*idim+(iy)*idim+(iz);
el=el+1;
}
for (k=0; k<el; k++) irow[k]=glob_row;
if ((info=SUNMatIns_PSBLAS(el,irow,icol,val,A))!=0)
fprintf(stderr,"From psb_c_dspins: %d\n",info);
}

return(info);
}
\end{lstlisting}

Observe that to speed-up the insertion procedure we are collecting together a certain number of rows to be inserted, specifically \texttt{10*NBMAX} for a defined value of NBMAX. It is clearly possible to execute one call for
each nonzero coefficient, however this would have a substantial computational
overhead. Therefore packing a ``certain amount of data'' (\texttt{10*NBMAX}) into each call
to the insertion routine is advisable. The best performing value of \texttt{NBMAX} depends on both the architecture of the computer being used and
on the problem structure.

\printbibliography[heading=bibintoc]

\end{document} 
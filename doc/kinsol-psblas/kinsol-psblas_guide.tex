\documentclass[twoside,a4paper]{refart}

\usepackage[utf8]{inputenc}
\usepackage{ae}
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}

\title{PSBLAS-KINSOL interface}
\author{Istituto per le Applicazioni del Calcolo ``M. Picone'',\\
	Consiglio Nazionale delle Ricerche \\
	Pasqua D'Ambra \\
	Fabio Durastante \\
	Salvatore Filippone \\
	PSBLAS 3.6.1 --- Interface Version 1}
\date{\today}
\emergencystretch1em 

\setcounter{tocdepth}{2}
\settextfraction{0.7}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\usepackage{listings}
\lstdefinestyle{CStyle}{
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
%	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C,
	morekeywords={N_Vector,sunindextype,psb_i_t,psb_c_descriptor,psb_c_dvector,booleantype,psb_c_info,psb_c_init,psb_cdall,psb_c_cdall_vl,psb_l_t}
}

\usepackage[backend=biber]{biblatex}
\bibliography{bibliography}

\begin{document}
	\maketitle
	
	\tableofcontents
	\newpage
	
	\section{The logic behind a PSBLAS instrumented application}
	
	The main aim of the PSBLAS library is the parallel implementation of iterative solvers
	for sparse linear systems,
	\begin{equation}\label{eq:linear_system}
		A \mathbf{x} = \mathbf{b}, \qquad A \in \mathbb{K}^{n \times n}, \qquad \mathbb{K} = \mathbb{R}, \mathbb{C},
	\end{equation}
	through the distributed memory paradigm operating with message
	passing. The library includes all the needed routines for this task, e.g, functions for multiplying sparse matrices by dense matrices, for solving block diagonal systems with triangular diagonal entries or for preprocessing sparse matrices.
	
	The pivotal choice to be made in this setting regards the distribution of the coefficient matrix $A$ for the linear system~\eqref{eq:linear_system}. In PSBLAS this choice is based on the \textbf{owner computes rule} \marginlabel{\textbf{Owner computes rule}}: each unknown is assigned to a process that will  own the corresponding row in the coefficient matrix and
	will  carry out all related computations. 
	
	If $A$ is obtained from the discretization of a Partial Differential Equation (PDE), this allocation strategy is equivalent to the choice of a partition of the mesh into {\em
		sub-domains}.
	 
	\attention PSBLAS supports \emph{any} distribution that keeps together 
	the coefficients of each matrix row there are \textbf{no other} constraints on
	the variable assignment. 
	
	Any PSBLAS application will always start with the construction of the parallel environment, i.e., of an MPI (virtual) parallel machine, that we call here context by means of the \lstinline[style=CStyle]|psb_c_init| function~as
\begin{lstlisting}[style=CStyle]
psb_i_t ictxt, iam, np;
ictxt = psb_c_init();
psb_c_info(ictxt,&iam,&np);
\end{lstlisting}
	that creates a parallel environment on \lstinline[style=CStyle]|np| processors $0,\ldots,\lstinline[style=CStyle]|np|-1$, of which we are process \lstinline[style=CStyle]|iam|.
	
	The next step is represented by the need of subdividing the index space among processes, and this creates a mapping from the ``global'' numbering $1,\ldots,n$ to a ``local'' numbering
	in each process. This means that each process $i$ will own a certain subset
	$1,\ldots,n_{\hbox{row}_i}$, each element of which corresponds to a certain element of $1\dots n$.
	
	Therefore, after the initialization the first step is to establish an index space, and
	this is done with a call to one of the variants of the \lstinline[style=CStyle]|psb_cdall| function to allocate a descriptor object \lstinline[style=CStyle]|psb_c_descriptor|:
\begin{description}
	\item[\fbox{\texttt{psb\_c\_cdall\_vg}}] the association between an index and a process is specified via an integer vector \lstinline[style=CStyle]|vg[]|, each index $i \in \{1,\ldots,\lstinline[style=CStyle]|ng|\}$ is assigned to process \lstinline[style=CStyle]|vg[i]|. The vector \lstinline[style=CStyle]|vg[]| must be identical on all calling processes, and its entries have the ranges $(0,\ldots,\lstinline[style=CStyle]|np|-1)$ or
	$(1,\ldots,\lstinline[style=CStyle]|np|)$ according to the fact that \lstinline[style=CStyle]|psb_c_set_index_base(0)| or \lstinline[style=CStyle]|psb_c_set_index_base(1)| has been called at the beginning. The size \lstinline[style=CStyle]|ng| is specified one can chose to use the entire
	vector \lstinline[style=CStyle]|vg[]|, thus having \lstinline[style=CStyle]|vg[ng]|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_vg(psb_l_t ng,psb_i_t *vg,psb_i_t ictxt,psb_c_descriptor *cdh);|
	\item[\fbox{\texttt{psb\_c\_cdall\_vl}}] the association is done by specifying the list of indices \lstinline[style=CStyle]|vl[nl]| assigned to
	the current process; thus, the global problem size \lstinline[style=CStyle]|nl| is given by
	the range of the aggregate of the individual vectors \lstinline[style=CStyle]|vl[]| specified in
	the calling processes. The subroutine will check how
	many times each entry in the global index space $(1,\ldots,\lstinline[style=CStyle]|nl|)$ is specified
	in the input lists \lstinline[style=CStyle]|vl[]|, therefore it allows for the presence of overlap in the
	input, and checks for the ``orphan'' indices. 
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_vl(psb_i_t nl,psb_l_t *vl,psb_i_t ictxt,psb_c_descriptor *cdh);|
	\item[\fbox{\texttt{psb\_c\_cdall\_nl}}] produces a generalized block-row distribution of the number of indices belonging to the current process in which each process $i$ gets assigned
	a consecutive chunk of $nl$ global indices,
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|psb_c_cdall_nl(psb_i_t nl,psb_i_t ictxt, psb_c_descriptor *cdh);|
\end{description}
	for the case of a simple minded block distribution, i.e., the index space is first numbered sequentially in a standard way, then the corresponding vector is distributed according to a block distribution directive. 
	%The discretization ensures there are IDIM *internal* points in each direction.
	
\noindent\rule{\columnwidth}{0.4pt}
We consider as example the finite difference discretization of the following boundary value problem
\begin{equation*}
	- \frac{b_1 \partial^2 u}{\partial x^2} - \frac{b_2 \partial^2 u}{\partial y^2} + \frac{a_1 \partial u}{\partial x} + \frac{a_2 \partial u}{\partial y} + a_3 u = 0, \qquad (x,y,z) \in [0,1]^3,
\end{equation*}
with Dirichlet boundary conditions, on a uniform grid with \lstinline[style=CStyle]|idim| node per size. All the allocation procedure can be expressed as
\begin{lstlisting}[style=CStyle]
psb_c_descriptor *cdh;
psb_i_t idim,nb,nlr, nl;
psb_l_t i,ng, *vl, k;

cdh=psb_c_new_descriptor();
psb_c_set_index_base(0);

/* Simple minded BLOCK data distribution */ 
ng = ((psb_l_t) idim)*idim*idim;  
nb = (ng+np-1)/np;
nl = nb;
if ( (ng -iam*nb) < nl) nl = ng -iam*nb; 
fprintf(stderr,"%d: Input data %d %ld %d %d\n",iam,idim,ng,nb, nl);
if ((vl=malloc(nb*sizeof(psb_l_t)))==NULL) {
	fprintf(stderr,"On %d: malloc failure\n",iam);
	psb_c_abort(ictxt);
}
i = ((psb_l_t)iam) * nb;
for (k=0; k<nl; k++)
	vl[k] = i+k; 
\end{lstlisting}
\noindent\rule{\columnwidth}{0.4pt}	

	Now that the initial distribution of the index space has been performed, we need to allocate  dense vectors and sparse matrices on such index space, and thus we define the complete topology of our computational problem. Since our task is to use the capabilities of SUNDIALS-KINSOL to solve for nonlinear problems, here lies the core of the interfacing between the two codes. In the next two Sections~\ref{sec:nvector}, and Section~\ref{sec:sunmatrix} we describe such encapsulation for dense vector, and sparse matrices. Then in Section~\ref{sec:sunlinsol} we describe the interfacing with the \textbf{linear solvers} and \textbf{preconditioners} 

	Complete information on the PSBLAS data structures, and functions that are mentioned along the text can be found in~\cite{psblasguide}.
	
	
	\section{The NVECTOR\_PSBLAS implementation}\label{sec:nvector}
	The NVECTOR\_PSBLAS implementation of the SUNDIALS NVECTOR module provides an interface to the PSBLAS code for handling distributed dense vectors. 
	It defines the \emph{content} field of \texttt{N\_Vector} to be a structure containing the PSBLAS descriptor for the data distribution, a PSBLAS vector of double, and the PSBLAS communicator (context).
	
\begin{lstlisting}[style=CStyle]
struct _N_VectorContent_PSBLAS {
	booleantype own_data;  /*ownership of data*/
	psb_c_descriptor *cdh; /*descriptor for data distribution*/
	psb_c_dvector *pvec;   /*PSBLAS vector*/
	int ictxt;             /*PSBLAS communicator*/
};
\end{lstlisting}
	
	\attention All the vectors that have to interact needs to be instantiated on the same parallel context \lstinline[style=CStyle]|ictxt|, and on the same data distribution \lstinline[style=CStyle]|cdh|.
	
	
	The header file to include when using this module is \texttt{nvector\_psblas.h}. The installed module library to link to is \texttt{sundials\_nvecpsblas.lib} where \texttt{.lib} is typically \texttt{.so} for shared libraries and \texttt{.a} for static libraries.
	
	\subsection{NVECTOR\_PSBLAS accessor macros}
	
	The following macros are provided to access the content of a NVECTOR\_PSBLAS vector. The suffix \texttt{\_P} in the names denotes the fact that the data are in distributed memory.

\begin{lstlisting}[style=CStyle]
#define NV_CONTENT_P(v)   ((N_VectorContent_PSBLAS)(v->content))
#define NV_DESCRIPTOR_P(v)(NV_CONTENT_P(v)->cdh)
#define NV_OWN_DATA_P(v)  (NV_CONTENT_P(v)->own_data)
#define NV_PVEC_P(v)      (NV_CONTENT_P(v)->pvec)
#define NV_ICTXT_P(v)     (NV_CONTENT_P(v)->ictxt)
\end{lstlisting}

\marginlabel{\lstinline[style=CStyle]|NV_CONTENT_P(v)|} this macro gives access to the contents of the PSBLAS vector \texttt{N\_Vector}.

\marginlabel{\lstinline[style=CStyle]|NV_DESCRIPTOR_P(v),NV_OWN_DATA_P(v),NV_PVEC_P(v)|} these macros give instead individual access to the parts of the content of a PSBLAS parallel \texttt{N\_Vector}.  

\marginlabel{\lstinline[style=CStyle]|NV_ICTXT_P(v)|} this macro provides the PSBLAS context used by the NVECTOR\_PSBLAS vectors.

\subsection{NVECTOR\_PSBLAS functions}

The NVECTOR\_PSBLAS implementation provides PSBLAS implementations of all the vectors operations listed in Tables~6.2, 6.3, and 6.4 of the original KINSOL library~\cite{kinsolguide}. Following the standard nomenclature of the SUNDIALS library, their names are obtained from the ones listed in Tables~6.2, 6.3, and 6.4 by appending the suffix \texttt{\_PSBLAS}. The NVECTOR\_PSBLAS implementation provides the following additional user--callable routines.

\begin{description}
	\item[\fbox{\texttt{N\_VNew\_PSBLAS}}] This function creates and allocates memory for a parallel vector
	on the PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh|
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VNew_PSBLAS(int ictxt, psb_c_descriptor *cdh);|
	
	\item[\fbox{\texttt{N\_VNewEmpty\_PSBLAS}}] This function creates a new PSBLAS vector with empty data array.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VNewEmpty_PSBLAS(int ictxt, psb_c_descriptor *cdh);|
	
	\item[\fbox{\texttt{N\_VMake\_PSBLAS}}] Function to create a PSBLAS \texttt{N\_Vector} with user data component. This function is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dgeins|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VMake_PSBLAS(int ictxt, psb_c_descriptor *cdh,psb_i_t m, psb_i_t *irow,double *val);|
	
	The PSBLAS context \lstinline[style=CStyle]|ictxt| with the communicator \lstinline[style=CStyle]|cdh| are the one defined for the whole programs, the integer \lstinline[style=CStyle]{m} is the number of rows in \lstinline[style=CStyle]{val[]} to be inserted, the array of integers \lstinline[style=CStyle]{irow} is the indices of the rows to be inserted. Specifically, row \lstinline[style=CStyle]|i| of \lstinline[style=CStyle]|val| will be inserted into the local row corresponding to the global index row index \lstinline[style=CStyle]|row[i]|.
	
	\attention This routine does not assemble the final vector. After the insertion of all the elements has been completed then the vector should be assembled by means of the \texttt{N\_VAsb\_PSBLAS} routine.
	
	\item[\fbox{\texttt{N\_VAsb\_PSBLAS}}] This routine assemble the NVector after that all the elements have been inserted into it, i.e., after that all the calls to the \texttt{N\_VMake\_PSBLAS} routine have been completed. This is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_dgeasb|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAsb_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VCloneVectorArray\_PSBLAS}}] This function creates an array of new parallel vectors (by cloning) an array of \lstinline[style=CStyle]|count| parallel vectors \lstinline[style=CStyle]|v|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector *N_VCloneVectorArray_PSBLAS(int count, N_Vector w)|
	
	\item[\fbox{\texttt{N\_VCloneVectorArrayEmpty\_PSBLAS}}] This function creates an array of \lstinline[style=CStyle]|count| new parallel vectors with empty data array on the same communicator and context of the vector \lstinline[style=CStyle]|w|. 
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector *N_VCloneVectorArrayEmpty_PSBLAS(int count, N_Vector w)|
	
	\item[\fbox{\texttt{N\_VDestroyVectorArray\_PSBLAS}}] This function to frees an array of \lstinline[style=CStyle]|count| \texttt{N\_Vector}s created with \texttt{N\_VCloneVectorArray\_PSBLAS}
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDestroyVectorArray_PSBLAS(N_Vector *vs, int count)|
	
	\item[\fbox{\texttt{N\_VGetLength\_PSBLAS}}] This function returns the \emph{global} vector length, this is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_cd_get_global_rows|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype N_VGetLength_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VGetLocalLength\_PSBLAS}}] This function returns the \emph{local} vector length, this is substantially a wrapper for the PSBLAS function \lstinline[style=CStyle]|psb_c_cd_get_local_rows|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|sunindextype N_VGetLocalLength_PSBLAS(N_Vector v)|
	
	\item[\fbox{\texttt{N\_VPrint\_PSBLAS}}] This function prints the local data in a parallel vector to \lstinline[style=CStyle]|stdout|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VPrint_PSBLAS(N_Vector x)|
	
	\item[\fbox{\texttt{N\_VPrintFile\_PSBLAS}}] This function prints the local data in a parallel vector to \lstinline[style=CStyle]|outfile|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VPrintFile_PSBLAS(N_Vector x, FILE* outfile)|
	
	\item[\fbox{\texttt{N\_VGetVectorID\_PSBLAS}}] This function returns the SUNDIALS identificative for the PSBLAS vector, since this is a custom implementation it returns the integer constant \lstinline[style=CStyle]|SUNDIALS_NVEC_CUSTOM|.
	
	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector_ID N_VGetVectorID_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VCloneEmpty\_PSBLAS}}] Clones a NVECTOR\_PSBLAS with a \lstinline[style=CStyle]|NULL| \lstinline[style=CStyle]|pvec| field, and with value \lstinline[style=CStyle]|SUNFALSE| in the \lstinline[style=CStyle]|own_data| field.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VCloneEmpty_PSBLAS(N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VClone\_PSBLAS}}] Clones a NVECTOR\_PSBLAS allocating its memory following the same communicator of the cloned one.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|N_Vector N_VClone_PSBLAS(N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VDestroy\_PSBLAS}}] Destroys a NVECTOR\_PSBLAS freeing both the memory allocated for the corresponding PSBLAS vector, and the memory allocated for the NVECTOR\_PSBLAS structure.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDestroy_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VSpace\_PSBLAS}}] Returns storage requirements for one NVECTOR\_PSBLAS. \lstinline[style=CStyle]|lrw| contains the number of realtype words and \lstinline[style=CStyle]|liw| contains the number of integer words.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VSpace_PSBLAS(N_Vector v, sunindextype *lrw,sunindextype *liw)|
 	
 	\item[\fbox{\texttt{N\_VGetArrayPointer\_PSBLAS}}] Returns a pointer to a realtype array from the NVECTOR\_PSBLAS, this is the local portion of the distributed PSBLAS vector encapsulated in the \texttt{N\_Vector} object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype *N_VGetArrayPointer_PSBLAS(N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VSetArrayPointer\_PSBLAS}}] This function is a dummy function, in PSBLAS we use \lstinline[language=Fortran]|allocatable| objects for the local part of the distributed vector, and, moreover, we assume having an arbitrary distribution of the indexes.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VSetArrayPointer_PSBLAS(psb_c_dvector *v_data, N_Vector v)|
 	
 	\item[\fbox{\texttt{N\_VLinearSum\_PSBLAS}}] Performs the AXPBY BLAS operation between to  NVECTOR\_PSBLAS, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VLinearSum_PSBLAS(realtype a, N_Vector x, realtype b, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VConst\_PSBLAS}}] Sets all components of the NVECTOR\_PSBLAS to a constant value and assembles it, the user \textbf{does not need} to assembly it.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VConst_PSBLAS(realtype c, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VProd\_PSBLAS}}] Performs the entry-wise multiplication of two NVECTOR\_PSBLAS, the result can be both out-of- and in-place.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VProd_PSBLAS(N_Vector x, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VDiv\_PSBLAS}}] Performs the entry-wise division of two NVECTOR\_PSBLAS, the result can be both out-of- and in-place, it does not check for possible zero entries in the denumerator. It is up to the user to guarantee that this does not happens.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VDiv_PSBLAS(N_Vector x, N_Vector y, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VScale\_PSBLAS}}] Scales an NVECTOR\_PSBLAS by a scalar c, the result can be both out-of- and in-place.
 	 
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VScale_PSBLAS(realtype c, N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VAbs\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the absolute values of the entries of the input.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAbs_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VInv\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the inverse of the entries of the input. It does not check for possible zero entries in the vector. It is up to the user to guarantee that this does not happens.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VInv_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VAddConst\_PSBLAS}}] Adds a scalar to all components of an NVECTOR\_PSBLAS and returns the result in another NVECTOR\_PSBLAS object.
 	 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VAddConst_PSBLAS(N_Vector x, realtype b, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VDotProd\_PSBLAS}}] Compute the dot product of two NVECTOR\_PSBLAS objects.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VDotProd_PSBLAS(N_Vector x, N_Vector y)|
 	
 	\item[\fbox{\texttt{N\_VMaxNorm\_PSBLAS}}] Compute the max norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMaxNorm_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNorm\_PSBLAS}}] Compute the weighted (by the size) 2-norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWrmsNorm_PSBLAS(N_Vector x, N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormMask\_PSBLAS}}] Returns the weighted root mean square norm of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| with
 	realtype weight vector \lstinline[style=CStyle]|w| built using only the elements of \lstinline[style=CStyle]|x| corresponding
 	to positive elements of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|id|.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWrmsNormMask_PSBLAS(N_Vector x,N_Vector w,N_Vector id)|
 	
 	\item[\fbox{\texttt{N\_VMin\_PSBLAS}}] Gives back the minimum entry of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMin_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VWL2Norm\_PSBLAS}}] Returns the weighted Euclidean $2$-norm of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| with realtype weight vector \lstinline[style=CStyle]|w|.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VWL2Norm_PSBLAS(N_Vector x, N_Vector w)|
 	
 	\item[\fbox{\texttt{N\_VL1Norm\_PSBLAS}}] Computes the 1-norm of an NVECTOR\_PSBLAS object.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VL1Norm_PSBLAS(N_Vector x)|
 	
 	\item[\fbox{\texttt{N\_VCompare\_PSBLAS}}] Compares the components of the NVECTOR\_PSBLAS \lstinline[style=CStyle]|x| to the realtype scalar \lstinline[style=CStyle]|c|
 	and returns an NVECTOR\_PSBLAS \lstinline[style=CStyle]|z| such that 
 	\begin{equation*}
 	z_i = \begin{cases}
 	1.0, & |x_i| \geq c,\\
 	0.0, & |x_i| \le c.
 	\end{cases}
 	\end{equation*}
 	\marginlabel{Prototype} \lstinline[style=CStyle]|void N_VCompare_PSBLAS(realtype c, N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VInvTest\_PSBLAS}}] Sets the entries of an NVECTOR\_PSBLAS to the inverse of the entries of the input. It checks for possible zero entries in the vector. This routine returns a boolean assigned to \lstinline[style=CStyle]|SUNTRUE| if all
 	components of the vector are nonzero (successful inversion) and returns \lstinline[style=CStyle]|SUNFALSE| otherwise.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|booleantype N_VInvTest_PSBLAS(N_Vector x, N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VConstrMask\_PSBLAS}}] Performs the following constraint tests: $x_i > 0$ if $c_i = 2$, $x_i \geq 0$ if $c_i = 1$,
 	$x_i \leq 0$ if $c_i = -1$, $x_i < 0$ if $c_i = -2$. There is no constraint on $x_i$ if $c_i = 0$.
 	This routine returns a boolean assigned to \lstinline[style=CStyle]|SUNFALSE| if any element failed
 	the constraint test and assigned to \lstinline[style=CStyle]|SUNTRUE| if all passed. It also sets a
 	mask vector \lstinline[style=CStyle]|m|, with elements equal to \lstinline[style=CStyle]|1.0| where the constraint test failed,
 	and \lstinline[style=CStyle]|0.0| where the test passed. This routine is used only for constraint
 	checking.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|booleantype N_VConstrMask_PSBLAS(N_Vector c, N_Vector x, N_Vector m)|
 	 
 	\item[\fbox{\texttt{N\_VMinQuotient\_PSBLAS}}] This routine returns the minimum of the quotients obtained by term-wise
 	dividing \lstinline[style=CStyle]|num[i]| by \lstinline[style=CStyle]|denom[i]| . A zero element in \lstinline[style=CStyle]|denom| will be skipped. If no
 	such quotients are found, then the large value \lstinline[style=CStyle]|BIG REAL| (defined in the
 	header file sundials \texttt{types.h}) is returned.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|realtype N_VMinQuotient_PSBLAS(N_Vector num, N_Vector denom)|
 	
\end{description}

\subsubsection{Fused operation}
\begin{description}
 	\item[\fbox{\texttt{N\_VLinearCombination\_PSBLAS}}] This routine computes the linear combination of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements
 	\begin{equation*}
 		z_i = \sum_{j=0}^{n_v - 1} c_j x_{j,i}, \qquad i=0,\ldots,n-1
 	\end{equation*}
 	where \lstinline[style=CStyle]|c| is an array of \lstinline[style=CStyle]|nv| scalars, \lstinline[style=CStyle]|X| is an array of NVECTOR\_PSBLAS. When \lstinline[style=CStyle]|z| is one of the vectors in \lstinline[style=CStyle]|X|, then it is assumed to be the first vector in the vector array.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearCombination_PSBLAS(int nvec, realtype* c, N_Vector* V,N_Vector z)|
 	
 	\item[\fbox{\texttt{N\_VScaleAddMulti\_PSBLAS}}] This routine scales and adds one vector to \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements:
 	\begin{equation*}
 		z_{j,i} = c_j x_i + y_{j,i}, \qquad j=0,\ldots,n_v-1, \qquad i=0,\ldots,n-1,
 	\end{equation*}
 	where \lstinline[style=CStyle]|c| is an array of \lstinline[style=CStyle]|nv| scalars.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleAddMulti_PSBLAS(int nvec, realtype* a, N_Vector x, N_Vector* Y, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VDotProdMulti\_PSBLAS}}] This routine computes the dot product of a vector with \lstinline[style=CStyle]|nv| other vectors.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VDotProdMulti_PSBLAS(int nvec, N_Vector x,N_Vector *Y, realtype* dotprods)|
 \end{description}
	\subsubsection{Vector array operations}
 \begin{description}
 	\item[\fbox{\texttt{N\_VLinearSumVectorArray\_PSBLAS}}] This routine computes the linear sum of two vector arrays
 	containing \lstinline[style=CStyle]|nv| vectors of \lstinline[style=CStyle]|n| elements:
 	\begin{equation*}
 		z_{j,i} = a x_{j,i} + b y_{j,i}, \qquad i=0,\ldots,n-1, \qquad j=0,\ldots,n_v -1.
 	\end{equation*}
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearSumVectorArray_PSBLAS(int nvec, realtype a, N_Vector* X, realtype b, N_Vector* Y, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VScaleVectorArray\_PSBLAS}}] This routine scales each vector of \lstinline[style=CStyle]|n| elements in a vector
 	array of \lstinline[style=CStyle]|n_v| vectors by a (potentially different) constant:
 	\begin{equation*}
 		z_{j,i} = c_j x_{j,i}, \qquad i=0,\ldots,n-1, \qquad j=0,\ldots,n_v-1.
 	\end{equation*}
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleVectorArray_PSBLAS(int nvec, realtype* c,N_Vector* X, N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VConstVectorArray\_PSBLAS}}] This routine sets each element in a vector of \lstinline[style=CStyle]|n|  elements in a vector array of \lstinline[style=CStyle]|nv|  vectors to the same value.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VConstVectorArray_PSBLAS(int nvecs, realtype c,N_Vector* Z)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormVectorArray\_PSBLAS}}] This routine computes the weighted root mean square
 	norm of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VWrmsNormVectorArray_PSBLAS(int nvecs, N_Vector* X,N_Vector* W, realtype* nrm)|
 	
 	\item[\fbox{\texttt{N\_VWrmsNormMaskVectorArray\_PSBLAS}}] This routine computes the masked weighted root mean square norm of \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VWrmsNormMaskVectorArray_PSBLAS(int nvec, N_Vector* X,N_Vector* W, N_Vector id,realtype* nrm)|
 	
 	\item[\fbox{\texttt{N\_VScaleAddMultiVectorArray\_PSBLAS}}] This routine scales and adds a vector in a vector array of
 	\lstinline[style=CStyle]|nv| vectors to the corresponding vector in \lstinline[style=CStyle]|ns| vector arrays.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VScaleAddMultiVectorArray_PSBLAS(int nvec, int nsum, realtype* a, N_Vector* X, N_Vector** Y, N_Vector** Z)|
 	
 	\item[\fbox{\texttt{N\_VLinearCombinationVectorArray\_PSBLAS}}] This routine computes the linear combination of \lstinline[style=CStyle]|ns| vector
 	arrays containing \lstinline[style=CStyle]|nv| vectors with \lstinline[style=CStyle]|n| elements.
 	
 	\marginlabel{Prototype} \lstinline[style=CStyle]|int N_VLinearCombinationVectorArray_PSBLAS(int nvec, int nsum, realtype* c, N_Vector** X, N_Vector* Z)|
\end{description}

By default all fused and vector array operations are disabled in the nvector PSBLAS module.
The following additional user-callable routines are provided to enable or disable fused and vector
array operations for a specific vector.
\begin{lstlisting}[style=CStyle]
int N_VEnableFusedOps_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearCombination_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleAddMulti_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableDotProdMulti_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearSumVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableConstVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableWrmsNormVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableWrmsNormMaskVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableScaleAddMultiVectorArray_PSBLAS(N_Vector v,booleantype tf);
int N_VEnableLinearCombinationVectorArray_PSBLAS(N_Vector v,booleantype tf);
\end{lstlisting}

\section{The SUNMATRIX\_PSBLAS implementation}\label{sec:sunmatrix}

\section{The SUNLINSOL\_PSBLAS implementation}\label{sec:sunlinsol}

\subsection{Algebraic Multigrid Preconditioners}

\printbibliography

\end{document}